plot(data.mds,type="t",main="NMDS using Euclidean Distance, ARTR.L Data")
plot(fit.d,col="purple", cex=0.7)
ordiplot(data.mds, display ="species", type ="n")
text(data.mds, display="sites", col="black", cex=0.7)
plot(data.mds,type="t",main="NMDS using Euclidean Distance, Soil Data")
plot(sig.fit.env,col="blue", cex=0.7)
#plot environmental loadings
plot(data.mds,type="t",main="NMDS using Euclidean Distance, Soil Data")
plot(sig.fit.env,col="blue", cex=0.7)
plot(data.mds,type="t",main="NMDS using Euclidean Distance, ARTR.L Data")
plot(fit.l,col="green", cex=0.7)
plot(data.mds,type="t",main="NMDS using Euclidean Distance, ARTR.D Data")
plot(fit.d,col="purple", cex=0.7)
library(plyr)
library(data.table)
library(splitstackshape)
# Read in Soils Data
dat <- read.csv("F:/Soils/SoilDataInputR.csv", header = T,nrows = 444)
# Pull out meaningful factors
df1 <- dat[,c(1:3,5:10,17,19,20,36,39:40,46,54)]
df2 <- dat[,c(1,40)] # Slope shape
View(df2)
SlopeShape <- df2[complete.cases(df2), ] #Remove rows with only NA
View(SlopeShape)
SS <- sub("LC", "CL", SlopeShape, ignore.case = FALSE)
SS
View(SlopeShape)
SS <- sub("LC", "CL", SlopeShape$SlopeShape, ignore.case = FALSE)
SS
SlopeShape$SS <- sub("LC", "CL", SlopeShape$SlopeShape, ignore.case = FALSE)
View(SlopeShape)
SlopeShape$SS <- sub("VC", "CV", SlopeShape$SS, ignore.case = FALSE)
View(SlopeShape)
SlopeShape$SS <- sub("VL", "LV", SlopeShape$SS, ignore.case = FALSE)
View(SlopeShape)
# Read in Soils Data
dat <- read.csv("F:/Soils/SoilDataInputR.csv", header = T,nrows = 444)
# Pull out meaningful factors
df1 <- dat[,c(1:3,5:10,17,19,20,36,39:40,46,54)]
df2 <- dat[,c(1,40)] # Slope shape
SlopeShape <- df2[complete.cases(df2), ] #Remove rows with only NA
SlopeShape$SlopeShape <- sub("LC", "CL", SlopeShape$SlopeShape, ignore.case = FALSE)
SlopeShape$SlopeShape <- sub("VC", "CV", SlopeShape$SlopeShape, ignore.case = FALSE)
SlopeShape$SlopeShape <- sub("VL", "LV", SlopeShape$SlopeShape, ignore.case = FALSE)
View(SlopeShape)
# Read in Soils Data
dat <- read.csv("F:/Soils/SoilDataInputR.csv", header = T,nrows = 444)
# Pull out meaningful factors
df1 <- dat[,c(1:3,5:10,17,19,20,36,39:40,46,54)]
df2 <- dat[,c(1,40)] # Slope shape
SlopeShape <- df2[complete.cases(df2), ] #Remove rows with only NA
# Combine Slope Shape categories
SlopeShape$SlopeShape <- sub("LC", "CL", SlopeShape$SlopeShape, ignore.case = FALSE)
SlopeShape$SlopeShape <- sub("VC", "CV", SlopeShape$SlopeShape, ignore.case = FALSE)
SlopeShape$SlopeShape <- sub("VL", "LV", SlopeShape$SlopeShape, ignore.case = FALSE)
df1$Elevation <- df1$Elevation/3.2808 # Change Elevation from ft to m
#Numeric Data
dat$top <- as.numeric(dat$top)
dat$bottom <- as.numeric(dat$bottom)
dat$ClayPercent <- as.numeric(dat$ClayPercent)
dat$Elevation <- as.numeric(dat$Elevation)
dat$SandPercent <- as.numeric(dat$SandPercent)
dat$pH <- as.numeric(dat$pH)
dat$Slope <- as.numeric(dat$Slope)
# Factor Data
dat$SlopeShape <- as.factor(dat$SlopeShape)
dat$DryValue <- as.factor(dat$DryValue)
dat$DryChroma <- as.factor(dat$DryChroma)
dat$MoistValue <- as.factor(dat$MoistValue)
dat$MoistChroma <- as.factor(dat$MoistChroma)
dat$CarbonateStage <- as.factor(dat$CarbonateStage)
dat$BioticCrustClass <- as.factor(dat$BioticCrustClass)
dat$DryHue <- as.factor(dat$DryHue)
dat$MoistHue <- as.factor(dat$MoistHue)
# Create Functions for extracting to single value per unique id(plot)
f1 <- function(x) max(x$ClayPercent, na.rm = T)
f111 <- function(x) min(x$ClayPercent, na.rm = T)
f2 <- function(x) summary(x[,-1])
f3 <- function(x) max(x$bottom, na.rm = T)
f4 <- function(x) max(x$SandPercent, na.rm = T)
f41 <- function(x) min(x$SandPercent, na.rm = T)
f5 <- function(x) max(x$Elevation, na.rm = T)
f6 <- function(x) max(x$pH, na.rm = T)
f7 <- function(x) min(x$pH, na.rm = T)
f8 <- function(x) max(x$DryValue, na.rm = T)
f9 <- function(x) min(x$DryValue, na.rm = T)
f10 <- function(x) max(x$DryChroma, na.rm = T)
f11 <- function(x) min(x$DryChroma, na.rm = T)
f12 <- function(x) max(x$MoistValue, na.rm = T)
f13 <- function(x) min(x$MoistValue, na.rm = T)
f14 <- function(x) max(x$MoistChroma, na.rm = T)
f15 <- function(x) min(x$MoistChroma, na.rm = T)
f16 <- function(x) max(x$CarbonateStage, na.rm = T)
f17 <- function(x) max(x$BioticCrustClass, na.rm = T)
f18 <- function(x) max(x$Slope, na.rm = T)
# pull out max/min for 1 value per unique id(plot)
#Numeric
maxClay <- ddply(.data = df1, .(id), .fun = f1)
names(maxClay)[2] <- 'maxClay'
minClay <- ddply(.data = df1, .(id), .fun = f111)
names(minClay)[2] <- 'minClay'
maxDepth <- ddply(.data = df1, .(id), .fun = f3)
names(maxDepth)[2] <- 'maxDepth'
maxSand <- ddply(.data = df1, .(id), .fun = f4)
names(maxSand)[2] <- 'maxSand'
minSand <- ddply(.data = df1, .(id), .fun = f41)
names(minSand)[2] <- 'minSand'
Elevation <- ddply(.data = df1, .(id), .fun = f5)
names(Elevation)[2] <- 'Elevation'
maxpH <- ddply(.data = df1, .(id), .fun = f6)
names(maxpH)[2] <- 'maxpH'
minpH <- ddply(.data = df1, .(id), .fun = f7)
names(minpH)[2] <- 'minpH'
Slope <- ddply(.data = df1, .(id), .fun = f18)
names(Slope)[2] <- 'Slope'
#Factor
maxDryValue <- ddply(.data = df1, .(id), .fun = f8)
names(maxDryValue)[2] <- 'maxDryValue'
minDryValue <- ddply(.data = df1, .(id), .fun = f9)
names(minDryValue)[2] <- 'minDryValue'
maxDryChroma <- ddply(.data = df1, .(id), .fun = f10)
names(maxDryChroma)[2] <- 'maxDryChroma'
minDryChroma <- ddply(.data = df1, .(id), .fun = f11)
names(minDryChroma)[2] <- 'minDryChroma'
maxMoistValue <- ddply(.data = df1, .(id), .fun = f12)
names(maxMoistValue)[2] <- 'maxMoistValue'
minMoistValue <- ddply(.data = df1, .(id), .fun = f13)
names(minMoistValue)[2] <- 'minMoistValue'
maxMoistChroma <- ddply(.data = df1, .(id), .fun = f14)
names(maxMoistChroma)[2] <- 'maxMoistChroma'
minMoistChroma <- ddply(.data = df1, .(id), .fun = f15)
names(minMoistChroma)[2] <- 'minMoistChroma'
CarbonateStage <- ddply(.data = df1, .(id), .fun = f16)
names(CarbonateStage)[2] <- 'CarbonateStage'
BioticCrustClass <- ddply(.data = df1, .(id), .fun = f17)
names(BioticCrustClass)[2] <- 'BioticCrustClass'
# Change moist Chroma to 1st horizon and 2nd horizon as a proxy
# for organic carbon accumulation in surface and subsurface horzons
# A lower chroma means more organic carbon. Grassland soils have
# higher fine root turnover.
# Surface
df1$Surface <- as.numeric(df1$top<1) # Turns surface horizon into 1, and all other into 0
max.func.sur <- function(df1) {
max.moist.sur <- max(df1$Surface)
return(data.frame(Surface = df1$MoistChroma[df1$Surface==max.moist.sur]))
}
Surface <- ddply(df1, .(id), max.func.sur)
names(Surface)[2] <- 'Surface'
# Subsurface
df1 <- getanID(data = df1, id.vars = "id") # Creates an ordered list of each horizon in a plot
df1$Subsurface <- as.numeric(df1$.id==2) # Makes subsurface horizon 1, and all other horizons 0
df1$MoistChroma[is.na(df1$MoistChroma)] <- 0
max.func.sub <- function(df1) {
max.moist.sub <- max(df1$Subsurface)
return(data.frame(Subsurface = df1$MoistChroma[df1$Subsurface==max.moist.sub]))
}
Subsurface <- ddply(df1, .(id), max.func.sub)
names(Subsurface)[2] <- 'Subsurface'
all <- join(Elevation, SlopeShape, by = 'id', type = 'inner')
all <- join(all, maxClay, by = 'id', type = 'inner')
all <- join(all, minClay, by = 'id', type = 'inner')
all <- join(all, maxSand, by = 'id', type = 'inner')
all <- join(all, minSand, by = 'id', type = 'inner')
all <- join(all, maxDepth, by = 'id', type = 'inner')
all <- join(all, maxpH, by = 'id', type = 'inner')
all <- join(all, minpH, by = 'id', type = 'inner')
all <- join(all, maxDryValue, by = 'id', type = 'inner')
all <- join(all, minDryValue, by = 'id', type = 'inner')
all <- join(all, maxDryChroma, by = 'id', type = 'inner')
all <- join(all, minDryChroma, by = 'id', type = 'inner')
all <- join(all, maxMoistValue, by = 'id', type = 'inner')
all <- join(all, minMoistValue, by = 'id', type = 'inner')
all <- join(all, maxMoistChroma, by = 'id', type = 'inner')
all <- join(all, minMoistChroma, by = 'id', type = 'inner')
all <- join(all, CarbonateStage, by = 'id', type = 'inner')
all <- join(all, BioticCrustClass, by = 'id', type = 'inner')
all <- join(all, Surface, by = 'id', type = 'inner')
all <- join(all, Subsurface, by = 'id', type = 'inner')
# Create new soil parameter where depth is binary.
# if the maximum depth is >50/100/150/200 then 1, if not then 0
all$Depth50 <- as.numeric(all$maxDepth > 50)
all$Depth100 <- as.numeric(all$maxDepth > 100)
all$Depth150 <- as.numeric(all$maxDepth > 150)
all$Depth200 <- as.numeric(all$maxDepth == 200)
write.csv(all,file="F:/Soils/SoilEnvironmentalData.csv")
# After all this I manually added Colby's AWS data to this file
#   and called it SoilEnvironmentalDataModWithColbyAWS.csv
#   Also remove first column of 12345678....
#---NMDS Script for Beef Basin Data --------
# this code has been modified from Plant Community Ecology at USU and various online sources
#### Took the file F:/LPI/LPIRelativeCover.csv and used
#### SUM and COUNTIF in Excel to find the column sums and
#### number of sites each veg was found at then I manually
#### removed those with COUNTIF below 5 AND SUMS below .05 (had to both be below to be removed)
#### Also cleaned up the data (combined SALS0 and SALSO, etc...)
data<-read.csv("F:/LPI/AprilLPIRelativeCoverCommonInExcel.csv",header=TRUE, row.names=1)
###data<-data[,2:ncol(data)]
# calculate dissimilarities, use function "vegdist"in VEGAN package
data.dis<-vegdist(data,method="bray")
dis.matrix<-as.matrix(data.dis)
# rankindex compares euclidean, bray-curtis, etc... for my data
rankindex(dis.matrix,data)
data.mds<-metaMDS(comm=data,distance="bray",trace=FALSE)
data.mds
# Stress <0.10 indicates that the ordination is good "with no real
# risk of drawing false inferences" (Clarke 1993, p. 26).
# linear fit is the fit between ordination values and distances
stressplot(data.mds)
###########################  ENVIRONMENTAL DATA  ###########################################
# read in Soil environmental data
data.env <- read.csv("F:/Soils/SoilEnvironmentalDataModWithColbyAWS.csv",header=TRUE, row.names=1)
###data.env<-data.env[,2:ncol(data.env)]
# read in Artr live and dead as environmental data
data.l <- read.csv("F:/ShrubDensity/HeightClass/LivePlotbySizeClass.csv", header=TRUE, row.names=1)
data.d <- read.csv("F:/ShrubDensity/HeightClass/DeadPlotbySizeClass.csv", header=TRUE, row.names=1)
# #add shrub height class densities as environmental data
#   # remove columns with only 0 values where there were no shrubs of that species in that size class found.
# A <- read.csv("F:/ShrubDensity/HeightClass/AprilAdensityM2.csv",row.names=1)
#   A <- A[, colSums(A != 0) > 0]
# B <- read.csv("F:/ShrubDensity/HeightClass/AprilBdensityM2.csv",row.names=1)
#   B <- B[, colSums(B != 0) > 0]
# C <- read.csv("F:/ShrubDensity/HeightClass/AprilCdensityM2.csv",row.names=1)
#   C <- C[, colSums(C != 0) > 0]
# D <- read.csv("F:/ShrubDensity/HeightClass/AprilDdensityM2.csv",row.names=1)
#   D <- D[, colSums(D != 0) > 0]
# E <- read.csv("F:/ShrubDensity/HeightClass/AprilEdensityM2.csv",row.names=1)
#   E <- E[, colSums(E != 0) > 0]
#function "envfit" fits environmental vectors or factors onto an ordination.
#requires ordination plot first before plot(fit)
fit.env <- envfit(data.mds,data.env,perm=1000)
fit.l <- envfit(data.mds,data.l,perm=1000)
fit.d <- envfit(data.mds,data.d,perm=1000)
# fit.a<-envfit(data.mds,A,perm=1000)
# fit.b<-envfit(data.mds,B,perm=1000)
# fit.c<-envfit(data.mds,C,perm=1000)
# fit.d<-envfit(data.mds,D,perm=1000)
# fit.e<-envfit(data.mds,E,perm=1000)
# Look at the significant factors
fit.env
fit.l
fit.d
# fit.a
# fit.b
# fit.c
# fit.d
# fit.e
### Choose only the significant environmental data
sig.data.env<-data.env[,c(1,7:9,19:25,28:29)]
sig.fit.env<-envfit(data.mds,sig.data.env,perm=1000)
sig.fit.env # Check that you pulled up the right factors.
# sig.A<-A[,c(1,3)]
# sig.fit.A<-envfit(data.mds,sig.A,perm=1000)
# sig.fit.A # Check that you pulled up the right factors.
#
# sig.B<-B[,c(2:3,9)]
# sig.fit.B<-envfit(data.mds,sig.B,perm=1000)
# sig.fit.B # Check that you pulled up the right factors.
#
# sig.C<-C[,c(1:3,6,8,12:13)]
# sig.fit.C<-envfit(data.mds,sig.C,perm=1000)
# sig.fit.C # Check that you pulled up the right factors.
#
# sig.D<-D[,c(3,8,11,13)]
# sig.fit.D<-envfit(data.mds,sig.D,perm=1000)
# sig.fit.D # Check that you pulled up the right factors.
#
# sig.E<-E[,c(3,7:8)]
# sig.fit.E<-envfit(data.mds,sig.E,perm=1000)
# sig.fit.E # Check that you pulled up the right factors.
#plotMDS
#ordiplot(data.mds)
ordiplot(data.mds, display ="species", type ="n")
text(data.mds, display="sites", col="black", cex=0.7)
text(data.mds, display="species", col="red", cex=0.7)
plot(data.mds,type="t",main="NMDS using Euclidean Distance, Soil Data")
plot(sig.fit.env,col="blue", cex=0.7)
#plot environmental loadings
plot(data.mds,type="t",main="NMDS using Euclidean Distance, Soil Data")
plot(sig.fit.env,col="blue", cex=0.7)
plot(data.mds,type="t",main="NMDS using Euclidean Distance, ARTR.L Data")
plot(fit.l,col="green", cex=0.7)
plot(data.mds,type="t",main="NMDS using Euclidean Distance, ARTR.D Data")
plot(fit.d,col="purple", cex=0.7)
library(plyr)
begay<-read.csv('F:/LPI/LPIindicatorsTBEGAY.csv')
ignacio<-read.csv('F:/LPI/LPIindicatorsTIGNACIOLEANTO.csv')
mido<-read.csv('F:/LPI/LPIindicatorsTMIDO.csv')
#Combined back into one LPI file
lpi3<-rbind(begay, ignacio, mido)
lpi3
write.csv(lpi3,file="F:/LPI/AprilLPIofAll3Soils.csv")
#Put into plot by species matrix
lpiApril<-xtabs(Any.Hit.N~Plot+Indicator, lpi3)
lpiApril
write.csv(lpiApril,file="F:/LPI/AprilLPIplotXspp.csv")
#add all hits on a plot basis, then divide each cell by the sum of a row
# to get how many times a spp was hit relative to how many in plot.
relcoverApril<-lpiApril/rowSums(lpiApril)
relcoverApril
write.csv(relcoverApril,file="F:/LPI/AprilLPIRelativeCover.csv")
library(plyr)
lpi <- read.csv("F:/LPI/USGSLPIRelativeCoverCommonInExcel.csv")
lpi <- lpi[-c(160:162),] # remove SUMS and COUNTIF rows at the bottom
View(lpi)
row.names(lpi)<-lpi$X
lpi <- lpi[,-1] # remove extra plot id column
View(lpi)
View(lpi)
lpi <- read.csv("F:/LPI/USGSLPIRelativeCoverCommonInExcel.csv")
lpi <- lpi[-c(160:162),] # remove SUMS and COUNTIF rows at the bottom
row.names(lpi)<-lpi$X
lpi <- lpi[,-1] # remove extra plot id column
lpi.l.relcov <- ((lpi$ARTR2)/rowSums(lpi))*100
# Code for #6
lpi.l.d.relcov <- ((lpi$ARTR2 + lpi$ARTR2.D)/rowSums(lpi))*100
lpi.l.relcov/lpi.l.d.relcov
# Do oridnation with soil properties, then put on the veg vecotrs to see
# how they relate to the properties.
# veg vectors:
# 1   Sage density (live+dead)
# 2   Sage density (live)
# 3   Proportion Sage individuals alive (talk to Susan about how to deal with sage absences)
# 4   Proportion Sage cover alive
# 5   Sage relative cover (live+dead)
# 6   Sage relative cover (live)
# 7   Perrenial Grass ralative cover
library(plyr)
# 1
# Sage density (live+dead)
# know area sampled: 30m transects X 2m belt X 3 transects per plot
# (2,3,& 4) = 180m2. Density in m2
# Total number of a spp. in a plot divided by the number of meters sampled in a plot(180m for shrub transects)
# Then add ARTR2 and ARTR2.D
class <- read.csv('F:/ShrubDensity/HeightClass/PlantDenDetail 8-21.csv')
class$total <- rowSums(class[,4:8]) #Sum all size classes for total density
total <- class[, c(1,2,3,9)] # Just total, size class removed
TotalplotXspp<-xtabs(total~Plot+SpeciesCode, total) # put in plot by spp matrix
TotaldensityM2 <- TotalplotXspp/180 # density per M2
write.csv(TotaldensityM2,file="F:/ShrubDensity/HeightClass/USGSTotalDensityM2.csv")
TotalDen <- read.csv("F:/ShrubDensity/HeightClass/USGSTotalDensityM2.csv",row.names=1)
TotalDen <- TotalDen[,c(8:9)]
TotalDen$L.D.DenM2 <- (TotalDen$ARTR2 + TotalDen$ARTR2.D)
# 2
# Sage density (live)
# Total number of a spp. in a plot divided by the number of meters sampled in a plot(180m for shrub transects)
# Then choose only ARTR2
TotalDen$L.DenM2 <- TotalDen$ARTR2
Sage.Env.USGS <- TotalDen[,c(3:4)]
# 3
# Proportion Sage individuals alive (talk to Susan about how to deal with sage absences)
# (number of live individual sagebrush plants)/(number of live + number of dead individual sagebrush plants)
TotalplotXspp<-xtabs(total~Plot+SpeciesCode, total) # put in plot by spp matrix
write.csv(TotalplotXspp,file="F:/ShrubDensity/HeightClass/USGSTotalplotXspp.csv")
Total <- read.csv("F:/ShrubDensity/HeightClass/USGSTotalplotXspp.csv",row.names=1)
Sage.Env.USGS$L.PropIndM2 <- ((Total$ARTR2)/(Total$ARTR2+Total$ARTR2.D))
View(Sage.Env.USGS)
lpi <- read.csv("F:/LPI/USGSLPIRelativeCoverCommonInExcel.csv")
lpi <- lpi[-c(160:162),] # remove SUMS and COUNTIF rows at the bottom
row.names(lpi)<-lpi$X
lpi <- lpi[,-1] # remove extra plot id column
lpi.l.relcov <- ((lpi$ARTR2)/rowSums(lpi))*100
# Code for #6
lpi.l.d.relcov <- ((lpi$ARTR2 + lpi$ARTR2.D)/rowSums(lpi))*100
# Combine for #4
Sage.Env.USGS$L.PropCov <- lpi.l.relcov/lpi.l.d.relcov
View(Sage.Env.USGS)
lpi.l.relcov <- ((lpi$ARTR2)/rowSums(lpi))*100
lpi.l.relcov
lpi.l.d.relcov <- ((lpi$ARTR2 + lpi$ARTR2.D)/rowSums(lpi))*100
lpi.l.d.relcov
Sage.Env.USGS$L.PropCov <- lpi.l.relcov/lpi.l.d.relcov
View(Sage.Env.USGS)
# Do oridnation with soil properties, then put on the veg vecotrs to see
# how they relate to the properties.
# veg vectors:
# 1   Sage density (live+dead)
# 2   Sage density (live)
# 3   Proportion Sage individuals alive (talk to Susan about how to deal with sage absences)
# 4   Proportion Sage cover alive
# 5   Sage relative cover (live+dead)
# 6   Sage relative cover (live)
# 7   Perrenial Grass ralative cover
library(plyr)
# 1
# Sage density (live+dead)
# know area sampled: 30m transects X 2m belt X 3 transects per plot
# (2,3,& 4) = 180m2. Density in m2
# Total number of a spp. in a plot divided by the number of meters sampled in a plot(180m for shrub transects)
# Then add ARTR2 and ARTR2.D
class <- read.csv('F:/ShrubDensity/HeightClass/PlantDenDetail 8-21.csv')
class$total <- rowSums(class[,4:8]) #Sum all size classes for total density
total <- class[, c(1,2,3,9)] # Just total, size class removed
TotalplotXspp<-xtabs(total~Plot+SpeciesCode, total) # put in plot by spp matrix
TotaldensityM2 <- TotalplotXspp/180 # density per M2
write.csv(TotaldensityM2,file="F:/ShrubDensity/HeightClass/USGSTotalDensityM2.csv")
TotalDen <- read.csv("F:/ShrubDensity/HeightClass/USGSTotalDensityM2.csv",row.names=1)
TotalDen <- TotalDen[,c(8:9)]
TotalDen$L.D.DenM2 <- (TotalDen$ARTR2 + TotalDen$ARTR2.D)
# 2
# Sage density (live)
# Total number of a spp. in a plot divided by the number of meters sampled in a plot(180m for shrub transects)
# Then choose only ARTR2
TotalDen$L.DenM2 <- TotalDen$ARTR2
Sage.Env.USGS <- TotalDen[,c(3:4)]
# 3
# Proportion Sage individuals alive (talk to Susan about how to deal with sage absences)
# (number of live individual sagebrush plants)/(number of live + number of dead individual sagebrush plants)
TotalplotXspp<-xtabs(total~Plot+SpeciesCode, total) # put in plot by spp matrix
write.csv(TotalplotXspp,file="F:/ShrubDensity/HeightClass/USGSTotalplotXspp.csv")
Total <- read.csv("F:/ShrubDensity/HeightClass/USGSTotalplotXspp.csv",row.names=1)
Sage.Env.USGS$L.PropIndM2 <- ((Total$ARTR2)/(Total$ARTR2+Total$ARTR2.D))
# 4
# Proportion Sage cover alive
# (SageRelativeCover(live))/(SageRelativeCover(live+dead))
lpi <- read.csv("F:/LPI/USGSLPIRelativeCoverCommonInExcel.csv")
lpi <- lpi[-c(160:162),] # remove SUMS and COUNTIF rows at the bottom
row.names(lpi)<-lpi$X
lpi <- lpi[,-1] # remove extra plot id column
lpi.l.relcov <- ((lpi$ARTR2)/rowSums(lpi))*100
# Code for #6
lpi.l.d.relcov <- ((lpi$ARTR2 + lpi$ARTR2.D)/rowSums(lpi))*100
# Combine for #4
Sage.Env.USGS$L.PropCov <- lpi.l.relcov/lpi.l.d.relcov
# 5
# Sage relative cover (live+dead)
# add all points of a spp. in a plot, then sum ARTR2 and ARTR2.D. Next divide by the total number of individuals of all species.
# Completed in #4
#Sage.Env.USGS$L.D.RelCov <- ((Total$ARTR2 + Total$ARTR2.D)/rowSums(Total))*100
# 6
# Sage relative cover (live)
# add all points of a spp. in a plot, then take only ARTR2 and  divide by the total number of individuals of all species.
# Completed in #4
#Sage.Env.USGS$L.RelCov <- ((Total$ARTR2)/rowSums(Total))*100
# 7
# Perrenial Grass relative cover
Sage.Env.USGS$PG.RelCov <- (lpi$ACHY+lpi$ARPU9+lpi$BOGR2+lpi$BOGR2.D+lpi$ELEL+lpi$HECO26+lpi$HECO26.D+lpi$SPCR+lpi$SPCR.D+lpi$HIJA)
#######################################################################
# Remove USGS, only April Data
Sage.Env.April <- Sage.Env.USGS[-c(1:60),] # remove usgs data
# Write USGS and April Data
write.csv(Sage.Env.April,file="F:/SageNMDSvariables/Sage.Env.April.csv")
write.csv(Sage.Env.USGS,file="F:/SageNMDSvariables/Sage.Env.USGS.csv")
View(Sage.Env.USGS)
# Do oridnation with soil properties, then put on the veg vecotrs to see
# how they relate to the properties.
# veg vectors:
# 1   Sage density (live+dead)
# 2   Sage density (live)
# 3   Proportion Sage individuals alive (talk to Susan about how to deal with sage absences)
# 4   Proportion Sage cover alive
# 5   Sage relative cover (live+dead)
# 6   Sage relative cover (live)
# 7   Perrenial Grass ralative cover
library(plyr)
# 1
# Sage density (live+dead)
# know area sampled: 30m transects X 2m belt X 3 transects per plot
# (2,3,& 4) = 180m2. Density in m2
# Total number of a spp. in a plot divided by the number of meters sampled in a plot(180m for shrub transects)
# Then add ARTR2 and ARTR2.D
class <- read.csv('F:/ShrubDensity/HeightClass/PlantDenDetail 8-21.csv')
class$total <- rowSums(class[,4:8]) #Sum all size classes for total density
total <- class[, c(1,2,3,9)] # Just total, size class removed
TotalplotXspp<-xtabs(total~Plot+SpeciesCode, total) # put in plot by spp matrix
TotaldensityM2 <- TotalplotXspp/180 # density per M2
write.csv(TotaldensityM2,file="F:/ShrubDensity/HeightClass/USGSTotalDensityM2.csv")
TotalDen <- read.csv("F:/ShrubDensity/HeightClass/USGSTotalDensityM2.csv",row.names=1)
TotalDen <- TotalDen[,c(8:9)]
TotalDen$L.D.DenM2 <- (TotalDen$ARTR2 + TotalDen$ARTR2.D)
# 2
# Sage density (live)
# Total number of a spp. in a plot divided by the number of meters sampled in a plot(180m for shrub transects)
# Then choose only ARTR2
TotalDen$L.DenM2 <- TotalDen$ARTR2
Sage.Env.USGS <- TotalDen[,c(3:4)]
# 3
# Proportion Sage individuals alive (talk to Susan about how to deal with sage absences)
# (number of live individual sagebrush plants)/(number of live + number of dead individual sagebrush plants)
TotalplotXspp<-xtabs(total~Plot+SpeciesCode, total) # put in plot by spp matrix
write.csv(TotalplotXspp,file="F:/ShrubDensity/HeightClass/USGSTotalplotXspp.csv")
Total <- read.csv("F:/ShrubDensity/HeightClass/USGSTotalplotXspp.csv",row.names=1)
Sage.Env.USGS$L.PropIndM2 <- ((Total$ARTR2)/(Total$ARTR2+Total$ARTR2.D))
# 4
# Proportion Sage cover alive
# (SageRelativeCover(live))/(SageRelativeCover(live+dead))
lpi <- read.csv("F:/LPI/USGSLPIRelativeCoverCommonInExcel.csv")
lpi <- lpi[-c(160:162),] # remove SUMS and COUNTIF rows at the bottom
row.names(lpi)<-lpi$X
lpi <- lpi[,-1] # remove extra plot id column
lpi.l.relcov <- ((lpi$ARTR2)/rowSums(lpi))*100
# Code for #6
lpi.l.d.relcov <- ((lpi$ARTR2 + lpi$ARTR2.D)/rowSums(lpi))*100
# Combine for #4
Sage.Env.USGS$L.PropCov <- lpi.l.relcov/lpi.l.d.relcov
# 5
# Sage relative cover (live+dead)
# add all points of a spp. in a plot, then sum ARTR2 and ARTR2.D. Next divide by the total number of individuals of all species.
Sage.Env.USGS$L.D.RelCov <- ((Total$ARTR2 + Total$ARTR2.D)/rowSums(Total))*100
# 6
# Sage relative cover (live)
# add all points of a spp. in a plot, then take only ARTR2 and  divide by the total number of individuals of all species.
Sage.Env.USGS$L.RelCov <- ((Total$ARTR2)/rowSums(Total))*100
# 7
# Perrenial Grass relative cover
Sage.Env.USGS$PG.RelCov <- (lpi$ACHY+lpi$ARPU9+lpi$BOGR2+lpi$BOGR2.D+lpi$ELEL+lpi$HECO26+lpi$HECO26.D+lpi$SPCR+lpi$SPCR.D+lpi$HIJA)
#######################################################################
# Remove USGS, only April Data
Sage.Env.April <- Sage.Env.USGS[-c(1:60),] # remove usgs data
# Write USGS and April Data
write.csv(Sage.Env.April,file="F:/SageNMDSvariables/Sage.Env.April.csv")
write.csv(Sage.Env.USGS,file="F:/SageNMDSvariables/Sage.Env.USGS.csv")
View(Sage.Env.USGS)
