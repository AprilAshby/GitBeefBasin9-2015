library(randomForest)
# Read in Soil and LPI Data
soil <- read.csv("F:/Soils/SoilEnvironmentaldataUSGSApril.csv",header=TRUE, row.names=1)
lpi <- read.csv("F:/LPI/Output/USGSLPIplotXspp.csv",header=TRUE, row.names=1)
belt <- read.csv("F:/ShrubDensity/PresenceAbsence/Output/USGSplotXspp.csv",header=TRUE, row.names=1)
# Keep only usgs sites that have both soil and veg data.
beltApril <- belt[c(61:159),]
beltUSGS <- belt[c("1","2","10","11","12","14","15","16","17","18","19","20","21","23","24","32","33","38","39","40","42","43","44","47","48","50","57","59","60","61","67","68","73","77","80","82","90"),]
belt <- rbind(beltApril, beltUSGS)
# Remove Predetermined Variables (Covariance and VIF)
soil <- subset(soil, select = -c(DepthClass,Aspect,Sand.50,Clay.50,pH.50,DryValue.50,EfferScale.50,AWHC.50,MaxClay,DWASand,DWA.AWHC,Tot.Texture,H1.Texture,SlopeShape,Tot.SandSize,H1.SandSize,H1.DryRed,H1.DryValue,H1.DryCClass,Tot.DryRed,Tot.DryValue,Tot.DryCClass,MaxSand,MaxpH,MaxDryValue,MaxAWHC))
# Combine Plant Data and Soils Data
soilplant <- soil
#soilplant$ARTR2 <- lpi$ARTR2
soilplant$ATCA2 <- lpi$ATCA2
# Which rows have NA present somewhere
rownames(soil)[rowSums(is.na(soil)) > 0]
# Replace NA with 0 (necesary for Boruta but not Random Forest)
soil[is.na(soil)] <- 0 # replace NA with 0
# Run Random Forest
live.rf = randomForest(as.numeric(ATCA2) ~ .
, data = soilplant,proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,mtry=2,
ntree = 500)
#var explained printed
print(live.rf)
(rf <- randomForest(x=soil,y=as.numeric(lpi$ATCA2),proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,mtry=2,
ntree = 501))
plot(live.rf)
plot(rf)
varImpPlot(live.rf, sort=TRUE, main = 'Live Sagebrush')
varImpPlot(rf, sort=TRUE, main = 'Live Sagebrush')
plot( predict(live.rf), y=live.rf$y)
abline(c(0,1),col=2)
plot( predict(rf), y=lpi$ARTR2)
abline(c(0,1),col=2)
data(nutrigenomic, package = "randomForestSRC")
## nice wrapper for making multivariate formula
mvrfsrc.f <- function(ynames, dat) {
as.formula(paste("Multivar(", paste(ynames, collapse = ","),paste(") ~ ."), sep = ""))
}
## multivariate mixed forest call
mv.obj <- rfsrc(mvrfsrc.f(colnames(nutrigenomic$lipids)),
data.frame(do.call(cbind, nutrigenomic)), nsplit = 10)
get.error <- function(obj) {
100 * c(sapply(obj$yvar.names, function(nn) {
o.coerce <- randomForestSRC:::coerce.multivariate(obj, nn)
if (o.coerce$family == "class") {
tail(o.coerce$err.rate[, 1], 1)
}
else {
tail(o.coerce$err.rate, 1) / var(o.coerce$yvar, na.rm = TRUE)
}
}))
}
## pull the standardized VIMP from a forest object
get.vimp <- function(obj) {
vimp <- 100 * do.call(cbind, lapply(obj$yvar.names, function(nn) {
o.coerce <- randomForestSRC:::coerce.multivariate(obj, nn)
if (o.coerce$family == "class") {
o.coerce$importance[, 1]
}
else {
o.coerce$importance / var(o.coerce$yvar, na.rm = TRUE)
}
}))
colnames(vimp) <- obj$yvar.names
vimp
}
serr <- get.error(mv.obj)
rfsrc?
?rfsrc
??rfsrc
install.packages("randomForestSRC")
mv.obj <- rfsrc(mvrfsrc.f(colnames(nutrigenomic$lipids)),
data.frame(do.call(cbind, nutrigenomic)), nsplit = 10)
#load the data
lpi <- read.csv("F:/LPI/Output/USGSLPIplotXspp.csv",header=TRUE, row.names=1)
soil <- read.csv("F:/Soils/SoilEnvironmentaldataUSGSApril.csv",header=TRUE, row.names=1)
# Remove Predetermined Variables (Covariance and VIF)
soil <- subset(soil, select = -c(DepthClass,Aspect,Sand.50,Clay.50,pH.50,DryValue.50,EfferScale.50,AWHC.50,MaxClay,DWASand,DWA.AWHC,Tot.Texture,H1.Texture,SlopeShape,Tot.SandSize,H1.SandSize,H1.DryRed,H1.DryValue,H1.DryCClass,Tot.DryRed,Tot.DryValue,Tot.DryCClass,MaxSand,MaxpH,MaxDryValue,MaxAWHC))
soil <- subset(soil, select = -c(Tot.MoistValue,DWAClay,H1.SandPercent,BioticCrustClass,H1.MoistCClass,H1.MoistCClass,CarbonateStage,Depth200, Tot.MoistCClass,H1.Depth,Slope,Elevation))
# Which rows have NA present somewhere
rownames(soil)[rowSums(is.na(soil)) > 0]
# Replace NA with 0 (necesary for Boruta but not Random Forest)
soil[is.na(soil)] <- 0 # replace NA with 0
# Combine Plant Data and Soils Data
sl <- soil
sl$ARTR2 <- lpi$ARTR2
# this data has 136 rows
nrow(sl)
# look at the first few
head(sl)
# splitdf function will return a list of training and testing sets
splitdf <- function(dataframe, seed=NULL) {
if (!is.null(seed)) set.seed(seed)
index <- 1:nrow(dataframe)
trainindex <- sample(index, trunc(length(index)/2))
trainset <- dataframe[trainindex, ]
testset <- dataframe[-trainindex, ]
list(trainset=trainset,testset=testset)
}
#apply the function
splits <- splitdf(sl, seed=808)
#it returns a list - two data frames called trainset and testset
str(splits)
# there are 68 observations in each data frame
lapply(splits,nrow)
lapply(splits,head)
#view the first few columns in each data frame
# save the training and testing sets as data frames
training <- splits$trainset
testing <- splits$testset
########### Optional: apply to  data using randomForest ###########
#load the randomForest library. if you havent installed it, run the next line
#install.packages("randomForest")
library(randomForest)
#fit the randomforest model
model <- randomForest(as.numeric(ARTR2) ~ .
, data = training,proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,mtry=2,
ntree = 500)
print(model)
#what are the important variables (via permutation)
varImpPlot(model, type=1)
#predict the outcome of the testing data
predicted <- predict(model, newdata=testing[ ,-23])
# what is the proportion variation explained in the outcome of the testing data?
# i.e., what is 1-(SSerror/SStotal)
actual <- testing$ARTR2
rsq <- 1-sum((actual-predicted)^2)/sum((actual-mean(actual))^2)
print(rsq)
library(randomForest)
install.packages("randomForest")
library(randomForest)
soil <- read.csv("E:/Soils/SoilEnvironmentaldataUSGSApril.csv",header=TRUE, row.names=1)
lpi <- read.csv("E:/LPI/Output/USGSLPIplotXspp.csv",header=TRUE, row.names=1)
belt <- read.csv("E:/ShrubDensity/PresenceAbsence/Output/USGSplotXspp.csv",header=TRUE, row.names=1)
beltApril <- belt[c(61:159),]
beltUSGS <- belt[c("1","2","10","11","12","14","15","16","17","18","19","20","21","23","24","32","33","38","39","40","42","43","44","47","48","50","57","59","60","61","67","68","73","77","80","82","90"),]
belt <- rbind(beltApril, beltUSGS)
soil <- subset(soil, select = -c(DepthClass,Aspect,Sand.50,Clay.50,pH.50,DryValue.50,EfferScale.50,AWHC.50,MaxClay,DWASand,DWA.AWHC,Tot.Texture,H1.Texture,SlopeShape,Tot.SandSize,H1.SandSize,H1.DryRed,H1.DryValue,H1.DryCClass,Tot.DryRed,Tot.DryValue,Tot.DryCClass,MaxSand,MaxpH,MaxDryValue,MaxAWHC))
# Combine Plant Data and Soils Data
soilplant <- soil
#soilplant$ARTR2 <- lpi$ARTR2
soilplant$ATCA2 <- lpi$ATCA2
rownames(soil)[rowSums(is.na(soil)) > 0]
?randomForest
soil <- subset(soil, -c(23,24,40,48,67))
View(soil)
View(soil)
soil <- subset(soil, select = -c(DepthClass,Aspect,Sand.50,Clay.50,pH.50,DryValue.50,EfferScale.50,AWHC.50,MaxClay,DWASand,DWA.AWHC,Tot.Texture,H1.Texture,SlopeShape,Tot.SandSize,H1.SandSize,H1.DryRed,H1.DryValue,H1.DryCClass,Tot.DryRed,Tot.DryValue,Tot.DryCClass,MaxSand,MaxpH,MaxDryValue,MaxAWHC))
soilplant <- soil
#soilplant$ARTR2 <- lpi$ARTR2
soilplant$ATCA2 <- lpi$ATCA2
# Which rows have NA present somewhere
rownames(soil)[rowSums(is.na(soil)) > 0]
soilnew <- na.omit(soil)
soil <- soilnew
View(soil)
soilnew <- na.omit(soilplant)
soilplant <- soilnew
live.rf = randomForest(as.numeric(ATCA2) ~ .
, data = soilplant,proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,mtry=2,
ntree = 500)
#var explained printed
print(live.rf)
summary(live.rf)
plot(live.rf)
(rf <- randomForest(x=soil,y=as.numeric(lpi$ATCA2),proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,mtry=2,
ntree = 501))
soil <- subset(soil, select = -c(DepthClass,Aspect,Sand.50,Clay.50,pH.50,DryValue.50,EfferScale.50,AWHC.50,MaxClay,DWASand,DWA.AWHC,Tot.Texture,H1.Texture,SlopeShape,Tot.SandSize,H1.SandSize,H1.DryRed,H1.DryValue,H1.DryCClass,Tot.DryRed,Tot.DryValue,Tot.DryCClass,MaxSand,MaxpH,MaxDryValue,MaxAWHC))
soilplant <- soil
#soilplant$ARTR2 <- lpi$ARTR2
soilplant$ATCA2 <- lpi$ATCA2
rownames(soilplant)[rowSums(is.na(soilplant)) > 0]
rownames(soil)[rowSums(is.na(soil)) > 0]
soil <- read.csv("F:/Soils/SoilEnvironmentaldataUSGSApril.csv",header=TRUE, row.names=1)
soil <- subset(soil, select = -c(DepthClass,Aspect,Sand.50,Clay.50,pH.50,DryValue.50,EfferScale.50,AWHC.50,MaxClay,DWASand,DWA.AWHC,Tot.Texture,H1.Texture,SlopeShape,Tot.SandSize,H1.SandSize,H1.DryRed,H1.DryValue,H1.DryCClass,Tot.DryRed,Tot.DryValue,Tot.DryCClass,MaxSand,MaxpH,MaxDryValue,MaxAWHC))
soil <- read.csv("E:/Soils/SoilEnvironmentaldataUSGSApril.csv",header=TRUE, row.names=1)
lpi <- read.csv("E:/LPI/Output/USGSLPIplotXspp.csv",header=TRUE, row.names=1)
belt <- read.csv("E:/ShrubDensity/PresenceAbsence/Output/USGSplotXspp.csv",header=TRUE, row.names=1)
beltApril <- belt[c(61:159),]
beltUSGS <- belt[c("1","2","10","11","12","14","15","16","17","18","19","20","21","23","24","32","33","38","39","40","42","43","44","47","48","50","57","59","60","61","67","68","73","77","80","82","90"),]
belt <- rbind(beltApril, beltUSGS)
soil <- subset(soil, select = -c(DepthClass,Aspect,Sand.50,Clay.50,pH.50,DryValue.50,EfferScale.50,AWHC.50,MaxClay,DWASand,DWA.AWHC,Tot.Texture,H1.Texture,SlopeShape,Tot.SandSize,H1.SandSize,H1.DryRed,H1.DryValue,H1.DryCClass,Tot.DryRed,Tot.DryValue,Tot.DryCClass,MaxSand,MaxpH,MaxDryValue,MaxAWHC))
soilplant <- soil
#soilplant$ARTR2 <- lpi$ARTR2
soilplant$ATCA2 <- lpi$ATCA2
rownames(soil)[rowSums(is.na(soil)) > 0]
live.rf = randomForest(as.numeric(ATCA2) ~ .
, data = soilplant,proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,mtry=2,
ntree = 500)
print(live.rf)
summary(live.rf)
(rf <- randomForest(x=soil,y=as.numeric(lpi$ATCA2),proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,mtry=2,
ntree = 501))
plot(live.rf)
varImpPlot(live.rf, sort=TRUE, main = 'Live Sagebrush')
pairs(soil)
plot( predict(live.rf), y=live.rf$y)
plot(soilplant$PedonDepth, soilplant$ATCA2)
plot(soilplant$DWApH, soilplant$ATCA2)
partialPlot(live.rf, soilplant, PedonDepth, "versicolor")
partialPlot(live.rf, soilplant, DWApH)
partialPlot(live.rf, soilplant, PedonDepth)
partialPlot(live.rf, soilplant, DWAClay)
partialPlot(live.rf, soilplant, DWApH)
soilplant <- na.omit(soilplant)
live.rf = randomForest(as.numeric(ATCA2) ~ .
, data = soilplant,proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,mtry=2,
ntree = 500)
print(live.rf)
Rplot(live.rf)
plot(live.rf)
varImpPlot(live.rf, sort=TRUE, main = 'Live Sagebrush')
plot( predict(live.rf), y=live.rf$y)
abline(c(0,1),col=2)
partialPlot(live.rf, soilplant, PedonDepth)
partialPlot(live.rf, soilplant, DWApH)
hist(soilplant$ATCA2)
?hist
hist(soilplant$ATCA2, breaks=35)
pairs(soilplant)
test <- soilplant[,c(23,10,12,20,21,22)]
test.rf = randomForest(as.numeric(ATCA2) ~ .
, data = test,proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,
ntree = 500)
plot(test.rf)
varImpPlot(live.rf, sort=TRUE, main = 'Live Sagebrush')
varImpPlot(test.rf, sort=TRUE, main = 'Live Sagebrush')
test.rf$y
plot( predict(test.rf), y=test.rf$y)
test.rf
live.rf
partialPlot(test.rf, soilplant, H1.pH)
partialPlot(test.rf, soilplant, DWApH)
test$MaxEffervescence <- as.ordered(test$MaxEffervescence)
test.rf = randomForest(as.numeric(ATCA2) ~ .
, data = test,proximity=TRUE,
importance=TRUE,keep.forest=TRUE,
na.action = na.omit,
ntree = 500)
test.rf
plot(test.rf)
varImpPlot(test.rf, sort=TRUE, main = 'Live Sagebrush')
plot( predict(test.rf), y=test.rf$y)
abline(c(0,1),col=2)
partialPlot(test.rf, soilplant, H1.pH)
partialPlot(test.rf, soilplant, DWApH)
partialPlot(test.rf, soilplant, MaxEffervescence)
pairs(test)
install.packages("quantregForest")
library(quantregForest)
test[-1]
test[1]
qrf <- quantregForest(x=test[-1], y=test[1], importance=TRUE)
test$ATCA2 <- as.numeric(test$ATCA2)
qrf <- quantregForest(x=test[-1], y=test[1], importance=TRUE)
check <- test[1]
str(check)
qrf <- quantregForest(x=test[-1], y=test$ATCA2, importance=TRUE)
plot(qrf)
## compute out-of-bag predictions
quant.outofbag <- predict(qrf)
## predict test data using all obervations per node for prediction
quant.newdata <- predict(qrf, newdata= Xtest, all=TRUE)
## look at computed importance measure of predictors
importance(qrf)
qrf
summary(qrf)
varImpPlot.qrf(qrf)
# K-Means Cluster Analysis 05/10/2016
# LPI Data
data <- read.csv("F:/LPI/Output/USGSLPIplotXspp.csv",header=TRUE, row.names=1)
# Check for the optimal number of clusters given the data
mydata <- data
# PCA before K-Means 05/11/2016
# LPI Data
data <- read.csv("F:/LPI/Output/USGSLPIPercentCover.csv",header=TRUE, row.names=1)
data.i <- subset(data, select = c(SPCR,PIED,LAOC3,OPPO,KRLA2,JUOS,HECO26,GUSA2,GUSA2.D,CHVI8,BRTE,BOGR2.D,BOGR2,Bare.Soil,ATCA2.D,ATCA2,ARTR2,ARTR2.D,AMID,ACHY) )
data.g <- subset(data, select = c(SPCR,HECO26,GUSA2,GUSA2.D,CHVI8,BRTE,BOGR2.D,BOGR2,Bare.Soil,ACHY) )
data.s <- subset(data, select = c(PIED,KRLA2,JUOS,CHVI8,Bare.Soil,ATCA2.D,ATCA2,ARTR2,ARTR2.D) )
data.f <- subset(data, select = c(LAOC3,OPPO,Bare.Soil,AMID) )
# plot variance of columns
# PCA before K-Means 05/11/2016
# LPI Data
data <- read.csv("F:/LPI/Output/USGSLPIPercentCover.csv",header=TRUE, row.names=1)
# plot variance of columns
mar <- par()$mar
par(mar=mar+c(0,5,0,0))
barplot(sapply(data, var), horiz=T, las=1, cex.names=0.5)
barplot(sapply(data, var), horiz=T, las=1, cex.names=0.5, log='x')
par(mar=mar)
par(mar=mar)
# Scale
data2 <- data.frame(scale(data))
# Verify variance is uniform
plot(sapply(data2, var))
# Proceed with principal components
pc <- princomp(data2)
plot(pc)
plot(pc, type='l')
summary(pc) # 3 components is 'elbow' but does not explain >85% variance(would need 23 components)(only explains about 7%)
# First four principal components
comp <- data.frame(pc$scores[,1:3])
View(comp)
plot(comp, pch=16, col=rgb(0,0,0,0.5))
library(rgl)
wss <- (nrow(comp)-1)*sum(apply(comp,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(comp,
centers=i)$withinss)
plot(1:15, wss, type="b", xlab="Number of Clusters",
ylab="Within groups sum of squares")
# From scree plot elbow occurs at k = 4 (or 6?)
# Apply k-means with k=4 (then try 6)
k <- kmeans(comp, 4, nstart=25, iter.max=1000)
library(RColorBrewer)
library(scales)
palette(alpha(brewer.pal(9,'Set1'), 0.5))
plot(comp, col=k$clust, pch=16)
# 3D plot
plot3d(comp$Comp.1, comp$Comp.2, comp$Comp.3, col=k$clust)
# Cluster sizes
sort(table(k$clust))
clust <- names(sort(table(k$clust)))
# First cluster
row.names(data[k$clust==clust[1],])
# Second Cluster
row.names(data[k$clust==clust[2],])
# Third Cluster
row.names(data[k$clust==clust[3],])
# Fourth Cluster
row.names(data[k$clust==clust[4],])
boxplot(data$ARTR2 ~ k$cluster,
xlab='Cluster', ylab='KRLA',
main='KRLA by Cluster')
data <- read.csv("F:/LPI/Output/USGSLPIPercentCover.csv",header=TRUE, row.names=1)
data.i <- subset(data, select = c(SPCR,PIED,LAOC3,OPPO,KRLA2,JUOS,HECO26,GUSA2,GUSA2.D,CHVI8,BRTE,BOGR2.D,BOGR2,Bare.Soil,ATCA2.D,ATCA2,ARTR2,ARTR2.D,AMID,ACHY) )
data.g <- subset(data, select = c(SPCR,HECO26,BRTE,BOGR2.D,BOGR2,Bare.Soil,ACHY) )
data.s <- subset(data, select = c(PIED,KRLA2,JUOS,CHVI8,Bare.Soil,ATCA2.D,ATCA2,ARTR2,ARTR2.D) )
data.f <- subset(data, select = c(LAOC3,OPPO,Bare.Soil,AMID) )
mar <- par()$mar
par(mar=mar+c(0,5,0,0))
barplot(sapply(data.s, var), horiz=T, las=1, cex.names=0.5)
barplot(sapply(data.s, var), horiz=T, las=1, cex.names=0.5, log='x')
par(mar=mar)
# Scale
data2 <- data.frame(scale(data.s))
# Verify variance is uniform
plot(sapply(data2, var))
# Proceed with principal components
pc <- princomp(data2)
plot(pc)
plot(pc, type='l')
summary(pc) # 3 components is 'elbow' but does not explain >85% variance(would need 23 components)(only explains about 7%)
comp <- data.frame(pc$scores[,1:7])
# Plot
plot(comp, pch=16, col=rgb(0,0,0,0.5))
library(rgl)
# Multi 3D plot
plot3d(comp$Comp.1, comp$Comp.2, comp$Comp.3)
comp <- data.frame(pc$scores[,1:3])
# Plot
plot(comp, pch=16, col=rgb(0,0,0,0.5))
comp <- data.frame(pc$scores[,1:4])
# Plot
plot(comp, pch=16, col=rgb(0,0,0,0.5))
wss <- (nrow(comp)-1)*sum(apply(comp,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(comp,
centers=i)$withinss)
plot(1:15, wss, type="b", xlab="Number of Clusters",
ylab="Within groups sum of squares")
# From scree plot elbow occurs at k = 4 (or 6?)
# Apply k-means with k=4 (then try 6)
k <- kmeans(comp, 6, nstart=25, iter.max=1000)
library(RColorBrewer)
library(scales)
palette(alpha(brewer.pal(9,'Set1'), 0.5))
plot(comp, col=k$clust, pch=16)
# 3D plot
plot3d(comp$Comp.1, comp$Comp.2, comp$Comp.3, col=k$clust)
# Cluster sizes
sort(table(k$clust))
clust <- names(sort(table(k$clust)))
# First cluster
row.names(data[k$clust==clust[1],])
# Second Cluster
row.names(data[k$clust==clust[2],])
# Third Cluster
row.names(data[k$clust==clust[3],])
# Fourth Cluster
row.names(data[k$clust==clust[4],])
# Fifth Cluster
row.names(data[k$clust==clust[5],])
# Sixth Cluster
row.names(data[k$clust==clust[6],])
# Compare accommodation by cluster in boxplot
boxplot(data$LAOC3 ~ k$cluster,
xlab='Cluster', ylab='LAOC3',
main='LAOC3 by Cluster')
View(data.s)
boxplot(data$PIED ~ k$cluster,
xlab='Cluster', ylab='PIED',
main='PIED by Cluster')
boxplot(data$JUOS ~ k$cluster,
xlab='Cluster', ylab='JUOS',
main='JUOS by Cluster')
View(data.s)
boxplot(data$ARTR2 ~ k$cluster,
xlab='Cluster', ylab='ARTR2',
main='JUOARTR2S by Cluster')
boxplot(data$ARTR2.D ~ k$cluster,
xlab='Cluster', ylab='ARTR2.D',
main='ARTR2.D by Cluster')
boxplot(data$ATCA2 ~ k$cluster,
xlab='Cluster', ylab='ATCA2',
main='ATCA2 by Cluster')
boxplot(data$ATCA2.D ~ k$cluster,
xlab='Cluster', ylab='ATCA2.D',
main='ATCA2.D by Cluster')
View(data.s)
boxplot(data$KRLA2 ~ k$cluster,
xlab='Cluster', ylab='KRLA2',
main='KRLA2 by Cluster')
boxplot(data$CHVI ~ k$cluster,
xlab='Cluster', ylab='CHVI',
main='CHVI by Cluster')
boxplot(data$CHVI8 ~ k$cluster,
xlab='Cluster', ylab='CHVI8',
main='CHVI8 by Cluster')
boxplot(data$Bare.Soil ~ k$cluster,
xlab='Cluster', ylab='CHVI8',
main='CHVI8 by Cluster')
boxplot(data$Bare.Soil ~ k$cluster,
xlab='Cluster', ylab='Bare.Soil',
main='Bare.Soil by Cluster')
#install.packages("vegan")
library(vegan)
library(MASS)
library(colorspace)
data<-read.csv("F:/LPI/AprilLPIRelativeCoverCommonInExcel.csv",header=TRUE, row.names=1)
data <- read.csv("F:/LPI/Output/USGSLPIPercentCover.csv",header=TRUE, row.names=1)
e.data.mds<-metaMDS(comm=data,distance="euc",trace=FALSE)
data.dis<-vegdist(data,method="euc")
dis.matrix<-as.matrix(data.dis)
rankindex(dis.matrix,data)
data <- read.csv("F:/LPI/Output/USGSLPIPercentCover.csv",header=TRUE, row.names=1)
e.data.mds<-metaMDS(comm=data,distance="euc",trace=FALSE)
e.data.mds #.09
e.data.mds<-metaMDS(comm=data,distance="euc",trace=FALSE)
e.data.mds #.09
e.data.mds #.09
e.data.mds<-metaMDS(comm=data,distance="euc",trace=FALSE)
e.data.mds #.09
e.data.mds #.09
plot.sc = scores(e.data.mds)
stressplot(e.data.mds)
data.env <- read.csv("F:/Soils/SoilEnvironmentalDataModWithColbyAWS.csv",header=TRUE, row.names=1)
data.env <- read.csv("F:/Soils/SoilEnvironmentaldataUSGSApril.csv",header=TRUE, row.names=1)
# read in SageEnvironmentalNMDS data
data.sage <- read.csv("F:/SageNMDSvariables/Sage.Env.April.csv",header=TRUE,row.names=1)
View(data.sage)
data.sage[is.na(data.sage)] <- 0 # replace NA with 0
# read in Artr live and dead as environmental data
fit.env <- envfit(e.data.mds,data.env,perm=1000)
data.sage[is.na(data.sage)] <- 0 # replace NA with 0
data.env[is.na(data.env)] <- 0 # replace NA with 0
fit.env <- envfit(e.data.mds,data.env,perm=1000)
fit.env
View(data.env)
sig.data.env<-data.env[,c(4,8,14,15,41)]
View(sig.data.env)
sig.fit.env<-envfit(e.data.mds,sig.data.env,perm=1000)
sig.fit.env # Check that you pulled up the right factors.
View(data.env)
sig.data.env<-data.env[,c(4,11,14,15,41)]
sig.fit.env<-envfit(e.data.mds,sig.data.env,perm=1000)
sig.fit.env # Check that you pulled up the right factors.
#plotMDS
orditkplot(e.data.mds, display="species", col="black", cex=0.7, pcol="gray",pch="+",xlim=c(-0.7,0.7),ylim=c(-0.7,0.4))
saveRDS(Plot, file="F:/5.24.16/Plot.Rdata")
saveRDS(Plot, file="F:/SageNMDSvariables/Plot.Rdata")
orditkplot(e.data.mds, display="species", col="black", cex=0.7, pcol="gray",pch="+",xlim=c(-0.7,0.7),ylim=c(-0.7,0.4))
saveRDS(Plot, file="F:/SageNMDSvariables/Plot.Rdata")
Plot <- readRDS("F:/SageNMDSvariables/Plot.Rdata")
plot(Plot)
orditkplot(e.data.mds, display="species", col="black", cex=0.7, pcol="gray",pch="+",xlim=c(-0.7,0.7),ylim=c(-0.7,0.4))
orditkplot(e.data.mds, display="species", col="black", cex=0.7, pcol="gray",pch="+",xlim=c(-0.7,0.7),ylim=c(-0.7,0.4))
orditkplot(e.data.mds, display="species", col="black", cex=0.7, pcol="gray",pch="+",xlim=c(-0.7,0.7),ylim=c(-0.7,0.4))
orditkplot(e.data.mds, display="species", col="black", cex=0.7, pcol="gray",pch="+",xlim=c(-0.4,0.25),ylim=c(-0.2,0.25))
saveRDS(Plot, file="F:/SageNMDSvariables/Plot.Rdata")
Plot <- readRDS("F:/SageNMDSvariables/Plot.Rdata")
plot(Plot)
title(main = "NMDS and Soils")
plot(sig.fit.env,col="blue", cex=0.7,font=2)
