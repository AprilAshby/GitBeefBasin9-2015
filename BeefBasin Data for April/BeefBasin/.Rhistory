# Do oridnation with soil properties, then put on the veg vecotrs to see
# how they relate to the properties.
# veg vectors:
# 1   Sage density (live+dead)
# 2   Sage density (live)
# 3   Proportion Sage individuals alive (talk to Susan about how to deal with sage absences)
# 4   Proportion Sage cover alive
# 5   Sage relative cover (live+dead)
# 6   Sage relative cover (live)
# 7   Perrenial Grass ralative cover
library(plyr)
# 1
# Sage density (live+dead)
# know area sampled: 30m transects X 2m belt X 3 transects per plot
# (2,3,& 4) = 180m2. Density in m2
# Total number of a spp. in a plot divided by the number of meters sampled in a plot(180m for shrub transects)
# Then add ARTR2 and ARTR2.D
class <- read.csv('F:/ShrubDensity/HeightClass/PlantDenDetail 8-21.csv')
class$total <- rowSums(class[,4:8]) #Sum all size classes for total density
total <- class[, c(1,2,3,9)] # Just total, size class removed
TotalplotXspp<-xtabs(total~Plot+SpeciesCode, total) # put in plot by spp matrix
TotaldensityM2 <- TotalplotXspp/180 # density per M2
write.csv(TotaldensityM2,file="F:/ShrubDensity/HeightClass/USGSTotalDensityM2.csv")
TotalDen <- read.csv("F:/ShrubDensity/HeightClass/USGSTotalDensityM2.csv",row.names=1)
TotalDen <- TotalDen[,c(8:9)]
TotalDen$L.D.DenM2 <- (TotalDen$ARTR2 + TotalDen$ARTR2.D)
# 2
# Sage density (live)
# Total number of a spp. in a plot divided by the number of meters sampled in a plot(180m for shrub transects)
# Then choose only ARTR2
TotalDen$L.DenM2 <- TotalDen$ARTR2
Sage.Env.USGS <- TotalDen[,c(3:4)]
# 3
# Proportion Sage individuals alive (talk to Susan about how to deal with sage absences)
# (number of live individual sagebrush plants)/(number of live + number of dead individual sagebrush plants)
TotalplotXspp<-xtabs(total~Plot+SpeciesCode, total) # put in plot by spp matrix
write.csv(TotalplotXspp,file="F:/ShrubDensity/HeightClass/USGSTotalplotXspp.csv")
Total <- read.csv("F:/ShrubDensity/HeightClass/USGSTotalplotXspp.csv",row.names=1)
Sage.Env.USGS$L.PropIndM2 <- ((Total$ARTR2)/(Total$ARTR2+Total$ARTR2.D))
# 4
# Proportion Sage cover alive
# (SageRelativeCover(live))/(SageRelativeCover(live+dead))
lpi <- read.csv("F:/LPI/USGSLPIRelativeCoverCommonInExcel.csv")
lpi <- lpi[-c(160:162),] # remove SUMS and COUNTIF rows at the bottom
row.names(lpi)<-lpi$X
lpi <- lpi[,-1] # remove extra plot id column
lpi.l.relcov <- ((lpi$ARTR2)/rowSums(lpi))*100
# Code for #6
lpi.l.d.relcov <- ((lpi$ARTR2 + lpi$ARTR2.D)/rowSums(lpi))*100
# Combine for #4
Sage.Env.USGS$L.PropCov <- lpi.l.relcov/lpi.l.d.relcov
# 5
# Sage relative cover (live+dead)
# add all points of a spp. in a plot, then sum ARTR2 and ARTR2.D. Next divide by the total number of individuals of all species.
Sage.Env.USGS$L.D.RelCov <- ((Total$ARTR2 + Total$ARTR2.D)/rowSums(Total))*100
# 6
# Sage relative cover (live)
# add all points of a spp. in a plot, then take only ARTR2 and  divide by the total number of individuals of all species.
Sage.Env.USGS$L.RelCov <- ((Total$ARTR2)/rowSums(Total))*100
# 7
# Perrenial Grass relative cover
Sage.Env.USGS$PG.RelCov <- (lpi$ACHY+lpi$ARPU9+lpi$BOGR2+lpi$BOGR2.D+lpi$ELEL+lpi$HECO26+lpi$HECO26.D+lpi$SPCR+lpi$SPCR.D+lpi$HIJA)
#######################################################################
# Remove USGS, only April Data
Sage.Env.April <- Sage.Env.USGS[-c(1:60),] # remove usgs data
# Write USGS and April Data
write.csv(Sage.Env.April,file="F:/SageNMDSvariables/Sage.Env.April.csv")
write.csv(Sage.Env.USGS,file="F:/SageNMDSvariables/Sage.Env.USGS.csv")
VegtoKeep <- Sage.Env.USGS[c("1","2","10","11","12","14","15","16","17","18","19","20","21","23","24","32","33","38","39","40","42","43","44","47","48","50","57","59","60","61","67","68","73","77","80","82","90"),]
View(Sage.Env.USGS)
View(VegtoKeep)
# Add April data back in
Keep <- rbind(Sage.Env.April, VegtoKeep)
write.csv(Keep,file="F:/SageNMDSvariables/Sage.Env.USGS.Keep.csv")
View(Keep)
#USGS Soil data
#install.packages('XLConnect')
library(plyr)
library(data.table)
library(splitstackshape)
library(aqp)
library(reshape2)
# Read in Soils data
udat <- read.csv("F:/Soils/USGSsoildataModForAprilsdata.csv", header = T,nrows = 444)
udat <- subset(udat, select = -c(Horizon,Theta_fc,Theta_pwp) )
#Look at data
names(udat)
sapply(udat, class)
# f2 <- function(x) summary(x[,-1])
# summary <- ddply( udat, .(id), function(x) summary(x[,-1]) )
#AWC
TotalAWC <- ddply(udat, 'id', summarize, TotalAWC = sum(AWHC, na.rm = T))
MaxAWC <- ddply(udat, 'id', summarize, MaxAWC = max(AWHC, na.rm = T))
maxDepth <- ddply( udat, .(id), function(x) max(x$bottom, na.rm = T) )
names(maxDepth)[2] <- 'maxDepth'
maxSand <- ddply( udat, .(id), function(x) max(x$SandPercent, na.rm = T) )
names(maxSand)[2] <- 'maxSand'
minSand <- ddply( udat, .(id), function(x) min(x$SandPercent, na.rm = T) )
names(minSand)[2] <- 'minSand'
minClay <- ddply( udat, .(id), function(x) min(x$ClayPercent, na.rm = T) )
names(minClay)[2] <- 'minClay'
maxClay <- ddply( udat, .(id), function(x) max(x$ClayPercent, na.rm = T) )
names(maxClay)[2] <- 'maxClay'
maxpH <- ddply( udat, .(id), function(x) max(x$pH, na.rm = T) )
names(maxpH)[2] <- 'maxpH'
minpH <- ddply( udat, .(id), function(x) min(x$pH, na.rm = T) )
names(minpH)[2] <- 'minpH'
#Factor
maxDryValue <- ddply(.data = udat, .(id), function(x) max(x$DryValue, na.rm = T))
names(maxDryValue)[2] <- 'maxDryValue'
minDryValue <- ddply(.data = udat, .(id), function(x) min(x$DryValue, na.rm = T))
names(minDryValue)[2] <- 'minDryValue'
maxDryChroma <- ddply(.data = udat, .(id), function(x) max(x$DryChroma, na.rm = T))
names(maxDryChroma)[2] <- 'maxDryChroma'
minDryChroma <- ddply(.data = udat, .(id), function(x) min(x$DryChroma, na.rm = T))
names(minDryChroma)[2] <- 'minDryChroma'
maxMoistValue <- ddply(.data = udat, .(id), function(x) max(x$MoistValue, na.rm = T))
names(maxMoistValue)[2] <- 'maxMoistValue'
minMoistValue <- ddply(.data = udat, .(id), function(x) min(x$MoistValue, na.rm = T))
names(minMoistValue)[2] <- 'minMoistValue'
maxMoistChroma <- ddply(.data = udat, .(id), function(x) max(x$MoistChroma, na.rm = T))
names(maxMoistChroma)[2] <- 'maxMoistChroma'
minMoistChroma <- ddply(.data = udat, .(id), function(x) min(x$MoistChroma, na.rm = T))
names(minMoistChroma)[2] <- 'minMoistChroma'
# Change moist Chroma to 1st horizon and 2nd horizon as a proxy
# for organic carbon accumulation in surface and subsurface horzons
# A lower chroma means more organic carbon. Grassland soils have
# higher fine root turnover.
# Surface
udat$Surface <- as.numeric(udat$top<1) # Turns surface horizon into 1, and all other into 0
max.func.sur <- function(udat) {
max.moist.sur <- max(udat$Surface)
return(data.frame(Surface = udat$MoistChroma[udat$Surface==max.moist.sur]))
}
Surface <- ddply(udat, .(id), max.func.sur)
names(Surface)[2] <- 'Surface'
# Subsurface
udat <- getanID(data = udat, id.vars = "id") # Creates an ordered list of each horizon in a plot
udat$Subsurface <- as.numeric(udat$.id==2) # Makes subsurface horizon 1, and all other horizons 0
udat$MoistChroma[is.na(udat$MoistChroma)] <- 0
max.func.sub <- function(udat) {
max.moist.sub <- max(udat$Subsurface)
return(data.frame(Subsurface = udat$MoistChroma[udat$Subsurface==max.moist.sub]))
}
Subsurface <- ddply(udat, .(id), max.func.sub)
names(Subsurface)[2] <- 'Subsurface'
#Numeric data
udat$top <- as.numeric(udat$top)
udat$bottom <- as.numeric(udat$bottom)
udat$ClayPercent <- as.numeric(udat$ClayPercent)
udat$SandPercent <- as.numeric(udat$SandPercent)
udat$pH <- as.numeric(udat$pH)
udat$AWHC <- as.numeric(udat$AWHC)
# Factor data
udat$DryHue <- as.factor(udat$DryHue)
udat$DryValue <- as.factor(udat$DryValue)
udat$DryChroma <- as.factor(udat$DryChroma)
udat$MoistHue <- as.factor(udat$MoistHue)
udat$MoistValue <- as.factor(udat$MoistValue)
udat$MoistChroma <- as.factor(udat$MoistChroma)
udat$Texture <- as.factor(udat$Texture)
udat$SandSize <- as.factor(udat$SandSize)
udat$Effervescence <- as.factor(udat$Effervescence)
udat$HzNum <- as.factor(udat$HzNum)
all <- join(maxClay, minClay, by = 'id', type = 'inner')
all <- join(all, maxSand, by = 'id', type = 'inner')
all <- join(all, minSand, by = 'id', type = 'inner')
all <- join(all, maxDepth, by = 'id', type = 'inner')
all <- join(all, maxpH, by = 'id', type = 'inner')
all <- join(all, minpH, by = 'id', type = 'inner')
all <- join(all, maxDryValue, by = 'id', type = 'inner')
all <- join(all, minDryValue, by = 'id', type = 'inner')
all <- join(all, maxDryChroma, by = 'id', type = 'inner')
all <- join(all, minDryChroma, by = 'id', type = 'inner')
all <- join(all, maxMoistValue, by = 'id', type = 'inner')
all <- join(all, minMoistValue, by = 'id', type = 'inner')
all <- join(all, maxMoistChroma, by = 'id', type = 'inner')
all <- join(all, minMoistChroma, by = 'id', type = 'inner')
all <- join(all, Surface, by = 'id', type = 'inner')
all <- join(all, Subsurface, by = 'id', type = 'inner')
# Create new soil parameter where depth is binary.
# if the maximum depth is >50/100/150/200 then 1, if not then 0
all$Depth50 <- as.numeric(all$maxDepth > 50)
all$Depth100 <- as.numeric(all$maxDepth > 100)
all$Depth150 <- as.numeric(all$maxDepth > 150)
all$Depth200 <- as.numeric(all$maxDepth == 200)
#Now calculate depth weighted averages of each continuous variable, then append these to the other variables.
#Convert to SoilProfileCollection
depths(udat) <- id ~ top + bottom
# within each profile, compute weighted means, over the intervals: 0-25,0-50,0-100, removing NA if present
d25 <- slab(udat, id ~ AWHC, slab.structure = c(0,25), slab.fun = mean, na.rm=TRUE)
d50 <- slab(udat, id ~ AWHC, slab.structure = c(0,50), slab.fun = mean, na.rm=TRUE)
d100 <- slab(udat, id ~ AWHC, slab.structure = c(0,100), slab.fun = mean, na.rm=TRUE)
# reshape to wide format, remove unneeded variables and rename.
AWC25 <- dcast(d25, id + top + bottom ~ variable, value.var = 'value')
AWC25 <- AWC25[,-c(2,3)]
names(AWC25)[2] <- 'AWC25'
AWC50 <- dcast(d50, id + top + bottom ~ variable, value.var = 'value')
AWC50 <- AWC50[,-c(2,3)]
names(AWC50)[2] <- 'AWC50'
AWC100 <- dcast(d100, id + top + bottom ~ variable, value.var = 'value')
AWC100 <- AWC100[,-c(2,3)]
names(AWC100)[2] <- 'AWC100'
all <- join(all, AWC25, by = 'id', type = 'inner')
all <- join(all, AWC50, by = 'id', type = 'inner')
all <- join(all, AWC100, by = 'id', type = 'inner')
all <- join(all, MaxAWC, by = 'id', type = 'inner')
all <- join(all, TotalAWC, by = 'id', type = 'inner')
write.csv(all,file="F:/Soils/SoilEnvironmentaldataUSGS.csv", row.names=FALSE)
# Add in Elevation, Slope Shape, Slope, Carbonate Stage, Biotic Crust Class
data <- read.csv("F:/Soils/SoilEnvironmentaldataUSGS.csv")
site <- read.csv("F:/BeefBasin Data For April/BeefBasin/formattedR/Site_Data.csv")
loc <- read.csv("F:/BeefBasin Data For April/BeefBasin/formattedR/locInfo.csv")
# Remove BLM Trend and Miller plots
site <- site[-c(66:77),]
site <- site[order(site$pedonID),] # Sort so plot 100 is by 9 same as data
loc <- loc[-c(66:77),]
loc <- loc[order(loc$Plot.Name),] # Sort so plot 100 is by 9 same as data
data$Elevation <- loc$altitude
data$Slope <- site$Slope
data$SlopeShape <- site$SlopeShape
data$CarbonateStage <- site$CarbonateStage
data$BioticCrustClass <- site$BioticCrustClass
# Combine Slope Shape categories
data$SlopeShape <- sub("LC", "CL", data$SlopeShape, ignore.case = FALSE)
data$SlopeShape <- sub("VC", "CV", data$SlopeShape, ignore.case = FALSE)
data$SlopeShape <- sub("VL", "LV", data$SlopeShape, ignore.case = FALSE)
data$SlopeShape <- as.factor(data$SlopeShape)
# replace -inf with na in min and max pH
is.na(data$minpH) <- !is.finite(data$minpH)
is.na(data$maxpH) <- !is.finite(data$maxpH)
write.csv(data,file="F:/Soils/SoilEnvironmentaldataUSGS.csv", row.names=FALSE)
SoilstoKeep <- data[c("CLHS01P","CLHS02P","CLHS10P","CLHS11P","CLHS12P","CLHS14P","CLHS15P","CLHS16P","CLHS17P","CLHS18P","CLHS19P","CLHS20P","CLHS21P","CLHS23P","CLHS24P","CLHS32P","CLHS33P","CLHS38P","CLHS39P","CLHS40P","CLHS42P","CLHS43P","CLHS44P","CLHS47P","CLHS48P","CLHS50P","CLHS57P","CLHS59P","CLHS60P","CLHS61P","CLHS67P","CLHS68P","CLHS73P","CLHS77P","CLHS80P","CLHS82P","CLHS90P"),]
View(SoilstoKeep)
april  <- read.csv("F:/Soils/SoilEnvironmentaldata.csv")
total <- rbind(april, data)
write.csv(total,file="F:/Soils/SoilEnvironmentaldataAll.csv", row.names=FALSE)
usgs <- read.csv("F:/Soils/SoilEnvironmentaldataUSGS.csv", header = T)
View(usgs)
usgs <- read.csv("F:/Soils/SoilEnvironmentaldataUSGS.csv", header = T,row.names=1)
View(usgs)
SoilstoKeep <- data[c("CLHS01P","CLHS02P","CLHS10P","CLHS11P","CLHS12P","CLHS14P","CLHS15P","CLHS16P","CLHS17P","CLHS18P","CLHS19P","CLHS20P","CLHS21P","CLHS23P","CLHS24P","CLHS32P","CLHS33P","CLHS38P","CLHS39P","CLHS40P","CLHS42P","CLHS43P","CLHS44P","CLHS47P","CLHS48P","CLHS50P","CLHS57P","CLHS59P","CLHS60P","CLHS61P","CLHS67P","CLHS68P","CLHS73P","CLHS77P","CLHS80P","CLHS82P","CLHS90P"),]
View(SoilstoKeep)
SoilstoKeep <- usgs[c("CLHS01P","CLHS02P","CLHS10P","CLHS11P","CLHS12P","CLHS14P","CLHS15P","CLHS16P","CLHS17P","CLHS18P","CLHS19P","CLHS20P","CLHS21P","CLHS23P","CLHS24P","CLHS32P","CLHS33P","CLHS38P","CLHS39P","CLHS40P","CLHS42P","CLHS43P","CLHS44P","CLHS47P","CLHS48P","CLHS50P","CLHS57P","CLHS59P","CLHS60P","CLHS61P","CLHS67P","CLHS68P","CLHS73P","CLHS77P","CLHS80P","CLHS82P","CLHS90P"),]
View(SoilstoKeep)
#####
# Keep only Soils data that has matching veg data.
# Add to April Soils
usgs <- read.csv("F:/Soils/SoilEnvironmentaldataUSGS.csv", header = T,row.names=1)
SoilstoKeep <- usgs[c("CLHS01P","CLHS02P","CLHS10P","CLHS11P","CLHS12P","CLHS14P","CLHS15P","CLHS16P","CLHS17P","CLHS18P","CLHS19P","CLHS20P","CLHS21P","CLHS23P","CLHS24P","CLHS32P","CLHS33P","CLHS38P","CLHS39P","CLHS40P","CLHS42P","CLHS43P","CLHS44P","CLHS47P","CLHS48P","CLHS50P","CLHS57P","CLHS59P","CLHS60P","CLHS61P","CLHS67P","CLHS68P","CLHS73P","CLHS77P","CLHS80P","CLHS82P","CLHS90P"),]
april  <- read.csv("F:/Soils/SoilEnvironmentaldata.csv")
total <- rbind(april, usgs)
write.csv(total,file="F:/Soils/SoilEnvironmentaldataAll.csv", row.names=FALSE)
View(SoilstoKeep)
View(total)
usgs <- read.csv("F:/Soils/SoilEnvironmentaldataUSGS.csv", header = T,row.names=1)
SoilstoKeep <- usgs[c("CLHS01P","CLHS02P","CLHS10P","CLHS11P","CLHS12P","CLHS14P","CLHS15P","CLHS16P","CLHS17P","CLHS18P","CLHS19P","CLHS20P","CLHS21P","CLHS23P","CLHS24P","CLHS32P","CLHS33P","CLHS38P","CLHS39P","CLHS40P","CLHS42P","CLHS43P","CLHS44P","CLHS47P","CLHS48P","CLHS50P","CLHS57P","CLHS59P","CLHS60P","CLHS61P","CLHS67P","CLHS68P","CLHS73P","CLHS77P","CLHS80P","CLHS82P","CLHS90P"),]
april  <- read.csv("F:/Soils/SoilEnvironmentaldata.csv")
total <- rbind(april, SoilstoKeep)
write.csv(total,file="F:/Soils/SoilEnvironmentaldataAll.csv", row.names=FALSE)
View(total)
View(april)
usgs <- read.csv("F:/Soils/SoilEnvironmentaldataUSGS.csv", header = T,row.names=1)
SoilstoKeep <- usgs[c("CLHS01P","CLHS02P","CLHS10P","CLHS11P","CLHS12P","CLHS14P","CLHS15P","CLHS16P","CLHS17P","CLHS18P","CLHS19P","CLHS20P","CLHS21P","CLHS23P","CLHS24P","CLHS32P","CLHS33P","CLHS38P","CLHS39P","CLHS40P","CLHS42P","CLHS43P","CLHS44P","CLHS47P","CLHS48P","CLHS50P","CLHS57P","CLHS59P","CLHS60P","CLHS61P","CLHS67P","CLHS68P","CLHS73P","CLHS77P","CLHS80P","CLHS82P","CLHS90P"),]
april  <- read.csv("F:/Soils/SoilEnvironmentaldata.csv", header = T,row.names=1)
total <- rbind(april, SoilstoKeep)
write.csv(total,file="F:/Soils/SoilEnvironmentaldataAll.csv", row.names=FALSE)
View(total)
cllibrary(rpart.plot)
library(RColorBrewer)
library(Boruta)
#library(rattle)
#The prp() has a lot of different options to check out
#Combine SageLive, LPI, and soils
sageL <- read.csv("F:/ShrubDensity/PresenceAbsence/AprilSageLivePresenceAbsence.csv", row.names=1)
colnames(sageL) <- c("sage")
# lpi <- read.csv("F:/LPI/AprilLPIRelativeCoverCommonInExcel.csv")
# lpi <- lpi[,-1] # remove plot names so don't duplicate below
soils <- read.csv("F:/Soils/SoilEnvironmentalDataModWithColbyAWS.csv", row.names=1)
live <- cbind(sageL,soils)
#Kappa and Class Functions
## Cohen's Kappa is the percent correctly classified corrected
##   by the number correctly classified that you'd expect
##   by chance.
kappa=function(x){
n=sum(x)
pobs=(x[1,1]+x[2,2])/n
pexp=(sum(x[1,])*sum(x[,1])+sum(x[2,])*sum(x[,2]))/n^2
kappa=(pobs-pexp)/(1-pexp)
t1=0
t2=0
t3=0
pii=x/n
pidot=apply(pii,1,sum)
pdotj=apply(pii,2,sum)
for(i in 1:2){
t1 = t1 + pii[i,i]*((1-pexp) - (1-pobs)*(pidot[i]+pdotj[i]))^2
}
t2 = pii[1,2]*(pdotj[1]+pidot[2])^2 + pii[2,1]*(pdotj[2] + pidot[1])^2
t3 = (pobs*pexp-2*pexp+pobs)^2
vhat = (t1 + t2*(1-pobs)^2 -t3)/(n*(1-pexp)^4)
se=sqrt(vhat)
return(c(kappa,se))
}
class.sum=function(truth,predicted){
xt=table(truth,round(predicted+0.000001))
pcc=round(100*sum(diag(xt))/sum(xt),2)
spec=round(100*xt[1,1]/sum(xt[1,]),2)
sens=round(100*xt[2,2]/sum(xt[2,]),2)
kap=round(kappa(xt)[1],4)
au=round(roc.area(truth,predicted)$A,4)
list(round(c(pcc,spec,sens,kap,au),3))
}
set.seed(1)
Boruta.live <- Boruta(sage~., data = live, doTrace = 2, ntree = 1000)
live.rf = randomForest(as.factor(sage) ~
AWC100 + AWC25 + AWC50 + BioticCrustClass +
CarbonateStage + Depth100 + Depth150 + Depth200 +
Depth50 + Elevation + MaxAWC + maxClay + maxSand +
maxDepth + maxDryChroma + maxDryValue + minClay +
maxMoistChroma + maxMoistValue + maxpH + minpH +
minDryChroma + minDryValue + minMoistChroma +
minMoistValue + minSand + SlopeShape +Subsurface +
Surface + TotalAWC
, data = live,proximity=TRUE,importance=TRUE,
keep.forest=TRUE)
live.rf$confusion
class.sum(live$sage,predict(live.rf,type="prob")[,2])
varImpPlot(live.rf, main = 'Live Sagebrush')
live.rf = randomForest(as.factor(sage) ~
AWC100 + AWC25 + AWC50 + BioticCrustClass +
CarbonateStage + Depth100 + Depth150 + Depth200 +
Depth50 + Elevation + MaxAWC + maxClay + maxSand +
maxDepth + maxDryChroma + maxDryValue + minClay +
maxMoistChroma + maxMoistValue + maxpH + minpH +
minDryChroma + minDryValue + minMoistChroma +
minMoistValue + minSand + SlopeShape +Subsurface +
Surface + TotalAWC
, data = live,proximity=TRUE,importance=TRUE,
keep.forest=TRUE)
live.rf$confusion
class.sum(live$sage,predict(live.rf,type="prob")[,2])
varImpPlot(live.rf, main = 'Live Sagebrush')
setwd("F:/BeefBasin Data for April/BeefBasin")
library(rgdal)
library(ggmap)
library(ggplot2)
library(aqp)
library(plyr)
library(reshape2)
#1. USGS (cLHS) pedon data
{
#1.a Horizon data. Remove useless columns and make names the same as April's data
usgsH <- read.csv("./formattedR/allPedons.csv", header = TRUE)
usgsH1 <- usgsH[,-c(2,3)]
names(usgsH1)[c(15,17)] <- c('SandPercent', 'ClayPercent')
usgsH2 <- usgsH1[,-c(11,13)] #Remove RF_knd, RF_sz (not needed)
usgsH2 <- usgsH2[c(1:10,12:17,11)] #reshuffle column names for easy joining with April's data
#1.b Rosetta data, give meaningful names, calculate Available Water Holding Capacity (AWC)
usgsR <- read.csv("./Rosetta/cLHS_Rosetta_AWC.csv", header = TRUE)
usgsR[,3] <- round(usgsR[,3], 3) #round to 3 decimal places
#Join horizon data and AWC
usgsH3 <- cbind(usgsH2, usgsR$AWHC)
names(usgsH3)[18] <- 'AWC'
#1.c Site data. Keep CarbonateState, ExcavationDepth, IRLDepth, IRL150
usgsS <- read.csv("./formattedR/Site_Data.csv", header = TRUE)
usgsS1 <- usgsS[,c(11,10,7:9)]
#1.d Location data
usgsL <- read.csv("./formattedR/locInfo.csv", header = TRUE)
names(usgsL) [1:3] <- c('PedonID', 'Latitude', 'Longitude') #Make names consistent with April's data
usgsL <- usgsL[ , -which(names(usgsL) %in% 'Date')] #Remove date field
}
# April Darger
# STAT 5600
# Final Project
library(rpart)
library(verification)
library(randomForest)
library(rpart.plot)
library(RColorBrewer)
library(Boruta)
#library(rattle)
#The prp() has a lot of different options to check out
#prp(model)
#This one has the best default
#fancyRpartPlot(model)
#Combine SageLive, LPI, and soils
sageL <- read.csv("F:/ShrubDensity/PresenceAbsence/AprilSageLivePresenceAbsence.csv", row.names=1)
colnames(sageL) <- c("sage")
# lpi <- read.csv("F:/LPI/AprilLPIRelativeCoverCommonInExcel.csv")
# lpi <- lpi[,-1] # remove plot names so don't duplicate below
soils <- read.csv("F:/Soils/SoilEnvironmentalDataModWithColbyAWS.csv", row.names=1)
live <- cbind(sageL,soils)
#Kappa and Class Functions
## Cohen's Kappa is the percent correctly classified corrected
##   by the number correctly classified that you'd expect
##   by chance.
kappa=function(x){
n=sum(x)
pobs=(x[1,1]+x[2,2])/n
pexp=(sum(x[1,])*sum(x[,1])+sum(x[2,])*sum(x[,2]))/n^2
kappa=(pobs-pexp)/(1-pexp)
t1=0
t2=0
t3=0
pii=x/n
pidot=apply(pii,1,sum)
pdotj=apply(pii,2,sum)
for(i in 1:2){
t1 = t1 + pii[i,i]*((1-pexp) - (1-pobs)*(pidot[i]+pdotj[i]))^2
}
t2 = pii[1,2]*(pdotj[1]+pidot[2])^2 + pii[2,1]*(pdotj[2] + pidot[1])^2
t3 = (pobs*pexp-2*pexp+pobs)^2
vhat = (t1 + t2*(1-pobs)^2 -t3)/(n*(1-pexp)^4)
se=sqrt(vhat)
return(c(kappa,se))
}
class.sum=function(truth,predicted){
xt=table(truth,round(predicted+0.000001))
pcc=round(100*sum(diag(xt))/sum(xt),2)
spec=round(100*xt[1,1]/sum(xt[1,]),2)
sens=round(100*xt[2,2]/sum(xt[2,]),2)
kap=round(kappa(xt)[1],4)
au=round(roc.area(truth,predicted)$A,4)
list(round(c(pcc,spec,sens,kap,au),3))
}
live.rf = randomForest(as.factor(sage) ~
AWC100 + AWC25 + AWC50 + BioticCrustClass +
CarbonateStage + Depth100 + Depth150 + Depth200 +
Depth50 + Elevation + MaxAWC + maxClay + maxSand +
maxDepth + maxDryChroma + maxDryValue + minClay +
maxMoistChroma + maxMoistValue + maxpH + minpH +
minDryChroma + minDryValue + minMoistChroma +
minMoistValue + minSand + SlopeShape +Subsurface +
Surface + TotalAWC
, data = live,proximity=TRUE,importance=TRUE,
keep.forest=TRUE)
live.rf$confusion
class.sum(live$sage,predict(live.rf,type="prob")[,2])
varImpPlot(live.rf, main = 'Live Sagebrush')
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
View(dat)
dat$Surface <- as.numeric(dat$top<1) # Turns surface horizon into 1, and all other into 0
View(dat)
dat <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
View(dat)
dat$Subsurface <- as.numeric(dat$.id==2) # Makes subsurface horizon 1, and all other horizons 0
View(dat)
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
dat <- getanID(data = dat, id.vars = "list") # Creates an ordered list of each horizon in a plot
dat <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
View(dat)
dat$list <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
View(dat)
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
dat$da <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
View(dat)
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
dat <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
dat$Subsurface <- as.numeric(dat$.id==2) # Makes subsurface horizon 1, and all other horizons 0
View(dat)
dat$MoistChroma[is.na(dat$MoistChroma)] <- 0
View(dat)
newdata <- dat[ which(dat$.id=='1'), ]
View(newdata)
H1 <- dat[ which(dat$.id=='1'), ]
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
dat <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
# Select horizon #1
H1 <- dat[ which(dat$.id=='1'), ]
View(`H1`)
colnames(H1) <- c("id", "surface","H1_Depth")
View(`H1`)
View(`H1`)
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
dat <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
# Select horizon #1
H1 <- dat[ which(dat$.id=='1'), ]
colnames(H1) = paste("H1_", colnames(H1))
View(`H1`)
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
dat <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
# Select horizon #1
H1 <- dat[ which(dat$.id=='1'), ]
View(`H1`)
H1 <- subset(dat, select = -c(Horizon,top,.id, HzNum,) )
H1 <- subset(dat, select = -c(Horizon,top,.id, HzNum) )
View(`H1`)
Plot <- H1[,c("Elevation","Aspect","Slope","SlopeShape")]
Plot <- subset(H1, select = c(Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass)
Plot <- subset(H1, select = c(Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass))
Plot <- subset(H1, select = c(Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass))
View(Plot)
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
dat <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
# Select horizon #1
H1 <- dat[ which(dat$.id=='1'), ]
# Remove top, Horizon, HzNum, .id
H1 <- subset(dat, select = -c(Horizon,top,.id, HzNum) )
# Pull out data that is not only for horizon 1
Plot <- subset(H1, select = c(Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass))
View(`H1`)
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
dat <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
# Select horizon #1
H1 <- dat[ which(dat$.id=='1'), ]
View(`H1`)
H1 <- subset(dat, select = -c(Horizon,top,.id, HzNum) )
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
dat <- getanID(data = dat, id.vars = "id") # Creates an ordered list of each horizon in a plot
# Select horizon #1
H1 <- dat[ which(dat$.id=='1'), ]
