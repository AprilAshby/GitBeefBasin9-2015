cf=ab$contributing_fraction,
layout=c(2,1), scales=list(x=list(alternating=1))
)
library(reshape)
# normalize horizon names: result is a factor
sp1$name <- generalize.hz(sp1$name,
new=c('O','A','B','C'),
pat=c('O', '^A','^B','C'))
data(sp1)
View(sp1)
depths(sp1) <- id ~ top + bottom
# normalize horizon names: result is a factor
sp1$name <- generalize.hz(sp1$name,
new=c('O','A','B','C'),
pat=c('O', '^A','^B','C'))
# compute slice-wise probability so that it sums to contributing fraction, from 0-150
a <- slab(sp1, fm= ~ name, cpm=1, slab.structure=0:150)
View(a)
# reshape into long format for plotting
a.long <- melt(a, id.vars=c('top','bottom'), measure.vars=c('O','A','B','C'))
View(a.long)
# plot horizon type proportions using panels
xyplot(top ~ value | variable, data=a.long, subset=value > 0,
ylim=c(150, -5), type=c('S','g'), horizontal=TRUE, layout=c(4,1), col=1 )
# again, this time using groups
xyplot(top ~ value, data=a.long, groups=variable, subset=value > 0,
ylim=c(150, -5), type=c('S','g'), horizontal=TRUE, asp=2)
# adjust probability to size of collection, from 0-150
a.1 <- slab(sp1, fm= ~ name, cpm=2, slab.structure=0:150)
View(a.1)
# reshape into long format for plotting
a.1.long <- melt(a.1, id.vars=c('top','bottom'), measure.vars=c('O','A','B','C'))
View(a.1.long)
# combine aggregation from `cpm` modes 1 and 2
g <- make.groups(cmp.mode.1=a.long, cmp.mode.2=a.1.long)
View(g)
# plot horizon type proportions
xyplot(top ~ value | variable, groups=which, data=g, subset=value > 0,
ylim=c(240, -5), type=c('S','g'), horizontal=TRUE, layout=c(4,1),
auto.key=list(lines=TRUE, points=FALSE, columns=2),
par.settings=list(superpose.line=list(col=c(1,2))),
scales=list(alternating=3))
# apply slice-wise evaluation of max probability, and assign ML-horizon at each slice
(gen.hz.ml <- get.ml.hz(a, c('O','A','B','C')))
View(gen.hz.ml)
data(sp3)
View(sp3)
# add new grouping factor
sp3$group <- 'group 1'
View(sp3)
sp3$group[as.numeric(sp3$id) > 5] <- 'group 2'
sp3$group <- factor(sp3$group)
is.factor(sp3$group)
View(sp3)
# upgrade to SPC
depths(sp3) <- id ~ top + bottom
site(sp3) <- ~ group
# custom 'slab' function, returning mean +/- 1SD
mean.and.sd <- function(values) {
m <- mean(values, na.rm=TRUE)
s <- sd(values, na.rm=TRUE)
upper <- m + s
lower <- m - s
res <- c(mean=m, lower=lower, upper=upper)
return(res)
}
# aggregate several variables at once, within 'group'
a <- slab(sp3, fm=group ~ L + A + B, slab.fun=mean.and.sd)
View(a)
library(lattice)
xyplot(
top ~ mean | variable, data=a, groups=group,
lower=a$lower, upper=a$upper, sync.colors=TRUE, alpha=0.5,
cf=a$contributing_fraction,
ylim=c(125,-5), layout=c(3,1), scales=list(x=list(relation='free')),
par.settings=list(superpose.line=list(lwd=2, col=c('RoyalBlue', 'Orange2'))),
panel=panel.depth_function,
prepanel=prepanel.depth_function,
auto.key=list(columns=2, lines=TRUE, points=FALSE)
)
# compare a single profile to the group-level aggregate values
a.1 <- slab(sp3[1, ], fm=group ~ L + A + B, slab.fun=mean.and.sd)
# manually update the group column
a.1$group <- 'profile 1'
# combine into a single data.frame:
g <- rbind(a, a.1)
# plot with customized line styles
xyplot(
top ~ mean | variable, data=g, groups=group, subscripts=TRUE,
lower=a$lower, upper=a$upper, ylim=c(125,-5),
layout=c(3,1), scales=list(x=list(relation='free')),
panel=panel.depth_function,
prepanel=prepanel.depth_function,
sync.colors=TRUE, alpha=0.25,
par.settings=list(superpose.line=list(col=c('orange', 'royalblue', 'black'),
lwd=2, lty=c(1,1,2))),
auto.key=list(columns=3, lines=TRUE, points=FALSE)
)
## convert mean value for each variable into long format
library(reshape)
# note that depths are no longer in order
a.wide <- cast(a, group + top + bottom ~ variable, value=c('mean'))
View(a.wide)
View(a.wide)
## again, this time for a user-defined slab from 40-60 cm
a <- slab(sp3, fm=group ~ L + A + B, slab.structure=c(40,60), slab.fun=mean.and.sd)
# now we have weighted average properties (within the defined slab)
# for each variable, and each group
(a.wide <- cast(a, group + top + bottom ~ variable, value=c('mean')))
View(a.wide)
?generalize.hz
data(sp1)
table(sp1$name)
sp1$genhz <- generalize.hz(sp1$name,
new=c('O','A','B','C','R'),
pat=c('O', '^A','^B','C','R'))
# see how we did / what we missed
table(sp1$genhz, sp1$name)
sp1$genhz <- generalize.hz(sp1$name,
new=c('O','A','B','C','R'),
pat=c('O^', '^A^','^B^','C','R'))
# see how we did / what we missed
table(sp1$genhz, sp1$name)
View(sp1)
a <- slab(Sub, fm= ~ Effervescence, cpm=1, slab.structure=0:200)
library(splitstackshape)
library(plyr)
library(aqp)
library(data.table)
library(reshape2)
library(tidyr)
# Read in data
# Manually in excel I added in second IL1_9 row of NA to dat so H2 still has 99obs
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
udat <- read.csv("F:/Soils/USGSsoildataModForAprilsdata.csv", header = T,nrows = 444)
udat$id <- extract_numeric(udat$id) # removes CLHS and P leaving only numbers.
# Creates an ordered list of each horizon in a plot
dat <- getanID(data = dat, id.vars = "id")
udat <- getanID(data = udat, id.vars = "id")
H1 <- dat[ which(dat$.id=='1'), ] # Pull out horizon #1
Plot <- subset(H1, select = c(id,Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass))# Pull out data that is for the whole plot
H1 <- subset(H1, select = -c(Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass))# Remove out data that is for the whole plot
dat <- subset(dat, select = -c(Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass))# Remove out data that is for the whole plot
# Combine April and USGS soils data
dat <- rbind(dat,udat)
# Add in USGS Elevation, Slope Shape, Slope, Carbonate Stage, Biotic Crust Class
# Remove BLM Trend and Miller plots
site <- read.csv("F:/BeefBasin Data For April/BeefBasin/formattedR/Site_Data.csv")
site <- site[-c(66:77),]
site <- site[order(site$pedonID),] # Sort so plot 100 is by 9 same as data
site$pedonID <- extract_numeric(site$pedonID) # removes CLHS and P leaving only numbers.
loc <- read.csv("F:/BeefBasin Data For April/BeefBasin/formattedR/locInfo.csv")
loc <- loc[-c(66:77),]
loc <- loc[order(loc$Plot.Name),] # Sort so plot 100 is by 9 same as data
loc$Plot.Name <- extract_numeric(loc$Plot.Name) # removes CLHS and P leaving only numbers.
# put into dataframe to add to april
id <-site$pedonID
Elevation <- loc$altitude
Aspect <- site$Aspect
df <- data.frame(id,Elevation,Aspect)
df$Slope <- site$Slope
df$SlopeShape <- site$SlopeShape
df$CarbonateStage <- site$CarbonateStage
df$BioticCrustClass <- site$BioticCrustClass
# Add to april Plot dataframe
Plot <- rbind(Plot,df)
# combine redundant categories
{Plot$SlopeShape <- sub("LC", "CL", Plot$SlopeShape, ignore.case = FALSE)
Plot$SlopeShape <- sub("VC", "CV", Plot$SlopeShape, ignore.case = FALSE)
Plot$SlopeShape <- sub("VL", "LV", Plot$SlopeShape, ignore.case = FALSE)
Plot$SlopeShape <- sub("LVQ", "LV", Plot$SlopeShape, ignore.case = FALSE)
Plot$SlopeShape <- as.factor(Plot$SlopeShape)}
# get the maximum depth of the entire pedon
PedonDepth <- ddply( dat, .(id), function(x) max(x$bottom, na.rm = T) )
names(PedonDepth)[2] <- 'PedonDepth'
# get the depth of each horizon
dat$Depth <- dat$bottom-dat$top
# Scale Hue - Redness Scale - Degree of Redness
# I have 4 Hue values:2.5YR, 5YR, 7.5YR, and 10YR
# They will be numbered from least(1) to most(4) red. 2.5YR=4, 5YR=3, 7.5YR=2, 10YR=1.
dat$Dry2 <- dat$DryHue
dat$Moist2 <- dat$MoistHue
dat$Effer2 <- dat$Effervescence
{
dat$DryHue <- sub("2.5YR", "4", dat$DryHue, ignore.case = FALSE)
dat$DryHue <- sub("7.5YR", "2", dat$DryHue, ignore.case = FALSE)
dat$DryHue <- sub("5YR", "3", dat$DryHue, ignore.case = FALSE)
dat$DryHue <- sub("10YR", "1", dat$DryHue, ignore.case = FALSE)
dat$MoistHue <- sub("2.5YR", "4", dat$MoistHue, ignore.case = FALSE)
dat$MoistHue <- sub("7.5YR", "2", dat$MoistHue, ignore.case = FALSE)
dat$MoistHue <- sub("5YR", "3", dat$MoistHue, ignore.case = FALSE)
dat$MoistHue <- sub("10YR", "1", dat$MoistHue, ignore.case = FALSE)
dat$Effervescence <- sub("VE", "4", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("ST", "3", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("SL", "2", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("VS", "1", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("NE", "0", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("LS", "2", dat$Effervescence, ignore.case = FALSE)
rename(dat, c("DryHue"="DryRed"))
rename(dat, c("Dry2"="DryHue"))
rename(dat, c("MoistHue"="MoistRed"))
rename(dat, c("Moist2"="MoistHue"))
rename(dat, c("Effervescence"="EfferScale"))
rename(dat, c("Effer2"="Effervescence"))
}
# write file before removing anything for use in slabs function below
write.csv(dat,file="F:/Soils/SoilDataAprilUSGSnotremoved.csv", row.names=FALSE)
# # remove anything you don't want duplicated in H1 and H2
# dat <- subset(dat, select = -c(top,bottom,Horizon,Theta_fc,Theta_pwp, HzNum,Texture,SandSize) )
H1 <- dat[ which(dat$.id=='1'), ] # Pull out horizon #1
H1 <- subset(H1, select=-c(.id))
H2 <- dat[! which(dat$.id=='1'), ] # Pull out horizon #1
H2 <- subset(H2, select=-c(.id))
#Now calculate depth weighted averages of each continuous variable, then append these to the other variables.
#Convert to SoilProfileCollection
data <- read.csv("F:/Soils/SoilDataAprilUSGSnotremoved.csv", header = T)
depths(data) <- id ~ top + bottom
# within each profile, compute weighted means, over the intervals: 0-25,0-50,0-100,0-150,0-200 removing NA if present
d25 <- slab(data, id ~ AWHC, slab.structure = c(0,25), slab.fun = mean, na.rm=TRUE)
d50 <- slab(data, id ~ AWHC, slab.structure = c(0,50), slab.fun = mean, na.rm=TRUE)
d100 <- slab(data, id ~ AWHC, slab.structure = c(0,100), slab.fun = mean, na.rm=TRUE)
d150 <- slab(data, id ~ AWHC, slab.structure = c(0,150), slab.fun = mean, na.rm=TRUE)
d200 <- slab(data, id ~ AWHC, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
s50 <- slab(data, id ~ AWHC, slab.structure = c(25,50), slab.fun = mean, na.rm=TRUE)
s100 <- slab(data, id ~ AWHC, slab.structure = c(50,100), slab.fun = mean, na.rm=TRUE)
s150 <- slab(data, id ~ AWHC, slab.structure = c(100,150), slab.fun = mean, na.rm=TRUE)
s200 <- slab(data, id ~ AWHC, slab.structure = c(150,200), slab.fun = mean, na.rm=TRUE)
# reshape to wide format, remove unneeded variables and rename.
AWC.0.25 <- dcast(d25, id + top + bottom ~ variable, value.var = 'value')
AWC.0.25 <- AWC.0.25[,-c(2,3)]
names(AWC.0.25)[2] <- 'AWC.0.25'
AWC.0.50 <- dcast(d50, id + top + bottom ~ variable, value.var = 'value')
AWC.0.50 <- AWC.0.50[,-c(2,3)]
names(AWC.0.50)[2] <- 'AWC.0.50'
AWC.0.100 <- dcast(d100, id + top + bottom ~ variable, value.var = 'value')
AWC.0.100 <- AWC.0.100[,-c(2,3)]
names(AWC.0.100)[2] <- 'AWC.0.100'
AWC.0.150 <- dcast(d150, id + top + bottom ~ variable, value.var = 'value')
AWC.0.150 <- AWC.0.150[,-c(2,3)]
names(AWC.0.150)[2] <- 'AWC.0.150'
AWC.0.200 <- dcast(d200, id + top + bottom ~ variable, value.var = 'value')
AWC.0.200 <- AWC.0.200[,-c(2,3)]
names(AWC.0.200)[2] <- 'AWC.0.200'
AWC.25.50 <- dcast(s50, id + top + bottom ~ variable, value.var = 'value')
AWC.25.50 <- AWC.25.50[,-c(2,3)]
names(AWC.25.50)[2] <- 'AWC.25.50'
AWC.50.100 <- dcast(s100, id + top + bottom ~ variable, value.var = 'value')
AWC.50.100 <- AWC.50.100[,-c(2,3)]
names(AWC.50.100)[2] <- 'AWC.50.100'
AWC.100.150 <- dcast(s150, id + top + bottom ~ variable, value.var = 'value')
AWC.100.150 <- AWC.100.150[,-c(2,3)]
names(AWC.100.150)[2] <- 'AWC.100.150'
AWC.150.200 <- dcast(s200, id + top + bottom ~ variable, value.var = 'value')
AWC.150.200 <- AWC.150.200[,-c(2,3)]
names(AWC.150.200)[2] <- 'AWC.150.200'
# within each profile, compute weighted means, removing NA if present
dwaclay <- slab(data, id ~ ClayPercent, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
dwasand <- slab(data, id ~ SandPercent, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
dwapH <- slab(data, id ~ pH, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
# reshape to wide format, remove unneeded variables and rename.
DWAClay <- dcast(dwaclay, id + top + bottom ~ variable, value.var = 'value')
DWAClay <- DWAClay[,-c(2,3)]
names(DWAClay)[2] <- 'DWAClay'
DWASand <- dcast(dwasand, id + top + bottom ~ variable, value.var = 'value')
DWASand <- DWASand[,-c(2,3)]
names(DWASand)[2] <- 'DWASand'
DWApH <- dcast(dwapH, id + top + bottom ~ variable, value.var = 'value')
DWApH <- DWApH[,-c(2,3)]
names(DWApH)[2] <- 'DWApH'
#Now calculate depth weighted averages of H2
#Convert to SoilProfileCollection
Sub <- H2
Sub$DryRed <- as.numeric(Sub$DryRed)
Sub$MoistRed <- as.numeric(Sub$MoistRed)
Sub$EfferScale <- as.numeric(Sub$EfferScale)
depths(Sub) <- id ~ top + bottom
# within each profile, compute weighted means, removing NA if present
subdwaclay <- slab(Sub, id ~ ClayPercent, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
subdwasand <- slab(Sub, id ~ SandPercent, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
subdwapH <- slab(Sub, id ~ pH, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
subawhc <- slab(Sub, id ~ AWHC, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
subdryred <- slab(Sub, id ~ DryRed, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
a <- slab(Sub, fm= ~ Effervescence, cpm=1, slab.structure=0:200)
View(a)
b <- slab(Sub, id= ~ Effervescence, cpm=1, slab.structure=0:200)
b <- slab(Sub, id ~ Effervescence, cpm=1, slab.structure=0:200)
View(b)
View(udat)
View(a)
View(`H2`)
c <- slab(Sub, fm= ~ DryHue, cpm=1, slab.structure=0:200)
View(c)
d <- slab(Sub, id ~ DryHue, cpm=1, slab.structure=0:200)
View(d)
tail(d)
e <- slab(Sub, fm= ~ DryHue, cpm=5, slab.structure=0:200)
library(reshape)
# load sample data, upgrade to SoilProfileCollection
data(sp1)
depths(sp1) <- id ~ top + bottom
# normalize horizon names: result is a factor
sp1$name <- generalize.hz(sp1$name,
new=c('O','A','B','C'),
pat=c('O', '^A','^B','C'))
# compute slice-wise probability so that it sums to contributing fraction, from 0-150
a <- slab(sp1, fm= ~ name, cpm=1, slab.structure=0:150)
# reshape into long format for plotting
a.long <- melt(a, id.vars=c('top','bottom'), measure.vars=c('O','A','B','C'))
# plot horizon type proportions using panels
xyplot(top ~ value | variable, data=a.long, subset=value > 0,
ylim=c(150, -5), type=c('S','g'), horizontal=TRUE, layout=c(4,1), col=1 )
# again, this time using groups
xyplot(top ~ value, data=a.long, groups=variable, subset=value > 0,
ylim=c(150, -5), type=c('S','g'), horizontal=TRUE, asp=2)
# adjust probability to size of collection, from 0-150
a.1 <- slab(sp1, fm= ~ name, cpm=2, slab.structure=0:150)
View(a)
View(a.1)
e <- slab(Sub, fm= ~ DryHue, cpm=2, slab.structure=0:200)
library(splitstackshape)
library(plyr)
library(aqp)
library(data.table)
library(reshape2)
library(tidyr)
# Read in data
# Manually in excel I added in second IL1_9 row of NA to dat so H2 still has 99obs
dat <- read.csv("F:/Soils/SoilDataFitUSGSColumns.csv", header = T,nrows = 444)
udat <- read.csv("F:/Soils/USGSsoildataModForAprilsdata.csv", header = T,nrows = 444)
udat$id <- extract_numeric(udat$id) # removes CLHS and P leaving only numbers.
# Creates an ordered list of each horizon in a plot
dat <- getanID(data = dat, id.vars = "id")
udat <- getanID(data = udat, id.vars = "id")
H1 <- dat[ which(dat$.id=='1'), ] # Pull out horizon #1
Plot <- subset(H1, select = c(id,Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass))# Pull out data that is for the whole plot
H1 <- subset(H1, select = -c(Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass))# Remove out data that is for the whole plot
dat <- subset(dat, select = -c(Elevation,Aspect,Slope,SlopeShape,CarbonateStage,BioticCrustClass))# Remove out data that is for the whole plot
# Combine April and USGS soils data
dat <- rbind(dat,udat)
# Add in USGS Elevation, Slope Shape, Slope, Carbonate Stage, Biotic Crust Class
# Remove BLM Trend and Miller plots
site <- read.csv("F:/BeefBasin Data For April/BeefBasin/formattedR/Site_Data.csv")
site <- site[-c(66:77),]
site <- site[order(site$pedonID),] # Sort so plot 100 is by 9 same as data
site$pedonID <- extract_numeric(site$pedonID) # removes CLHS and P leaving only numbers.
loc <- read.csv("F:/BeefBasin Data For April/BeefBasin/formattedR/locInfo.csv")
loc <- loc[-c(66:77),]
loc <- loc[order(loc$Plot.Name),] # Sort so plot 100 is by 9 same as data
loc$Plot.Name <- extract_numeric(loc$Plot.Name) # removes CLHS and P leaving only numbers.
# put into dataframe to add to april
id <-site$pedonID
Elevation <- loc$altitude
Aspect <- site$Aspect
df <- data.frame(id,Elevation,Aspect)
df$Slope <- site$Slope
df$SlopeShape <- site$SlopeShape
df$CarbonateStage <- site$CarbonateStage
df$BioticCrustClass <- site$BioticCrustClass
# Add to april Plot dataframe
Plot <- rbind(Plot,df)
# combine redundant categories
{Plot$SlopeShape <- sub("LC", "CL", Plot$SlopeShape, ignore.case = FALSE)
Plot$SlopeShape <- sub("VC", "CV", Plot$SlopeShape, ignore.case = FALSE)
Plot$SlopeShape <- sub("VL", "LV", Plot$SlopeShape, ignore.case = FALSE)
Plot$SlopeShape <- sub("LVQ", "LV", Plot$SlopeShape, ignore.case = FALSE)
Plot$SlopeShape <- as.factor(Plot$SlopeShape)}
# get the maximum depth of the entire pedon
PedonDepth <- ddply( dat, .(id), function(x) max(x$bottom, na.rm = T) )
names(PedonDepth)[2] <- 'PedonDepth'
# get the depth of each horizon
dat$Depth <- dat$bottom-dat$top
# Scale Hue - Redness Scale - Degree of Redness
# I have 4 Hue values:2.5YR, 5YR, 7.5YR, and 10YR
# They will be numbered from least(1) to most(4) red. 2.5YR=4, 5YR=3, 7.5YR=2, 10YR=1.
dat$Dry2 <- dat$DryHue
dat$Moist2 <- dat$MoistHue
dat$Effer2 <- dat$Effervescence
{
dat$DryHue <- sub("2.5YR", "4", dat$DryHue, ignore.case = FALSE)
dat$DryHue <- sub("7.5YR", "2", dat$DryHue, ignore.case = FALSE)
dat$DryHue <- sub("5YR", "3", dat$DryHue, ignore.case = FALSE)
dat$DryHue <- sub("10YR", "1", dat$DryHue, ignore.case = FALSE)
dat$MoistHue <- sub("2.5YR", "4", dat$MoistHue, ignore.case = FALSE)
dat$MoistHue <- sub("7.5YR", "2", dat$MoistHue, ignore.case = FALSE)
dat$MoistHue <- sub("5YR", "3", dat$MoistHue, ignore.case = FALSE)
dat$MoistHue <- sub("10YR", "1", dat$MoistHue, ignore.case = FALSE)
dat$Effervescence <- sub("VE", "4", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("ST", "3", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("SL", "2", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("VS", "1", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("NE", "0", dat$Effervescence, ignore.case = FALSE)
dat$Effervescence <- sub("LS", "2", dat$Effervescence, ignore.case = FALSE)
rename(dat, c("DryHue"="DryRed"))
rename(dat, c("Dry2"="DryHue"))
rename(dat, c("MoistHue"="MoistRed"))
rename(dat, c("Moist2"="MoistHue"))
rename(dat, c("Effervescence"="EfferScale"))
rename(dat, c("Effer2"="Effervescence"))
}
# write file before removing anything for use in slabs function below
write.csv(dat,file="F:/Soils/SoilDataAprilUSGSnotremoved.csv", row.names=FALSE)
# # remove anything you don't want duplicated in H1 and H2
# dat <- subset(dat, select = -c(top,bottom,Horizon,Theta_fc,Theta_pwp, HzNum,Texture,SandSize) )
H1 <- dat[ which(dat$.id=='1'), ] # Pull out horizon #1
H1 <- subset(H1, select=-c(.id))
H2 <- dat[! which(dat$.id=='1'), ] # Pull out horizon #1
H2 <- subset(H2, select=-c(.id))
#Now calculate depth weighted averages of each continuous variable, then append these to the other variables.
#Convert to SoilProfileCollection
data <- read.csv("F:/Soils/SoilDataAprilUSGSnotremoved.csv", header = T)
depths(data) <- id ~ top + bottom
# within each profile, compute weighted means, over the intervals: 0-25,0-50,0-100,0-150,0-200 removing NA if present
d25 <- slab(data, id ~ AWHC, slab.structure = c(0,25), slab.fun = mean, na.rm=TRUE)
d50 <- slab(data, id ~ AWHC, slab.structure = c(0,50), slab.fun = mean, na.rm=TRUE)
d100 <- slab(data, id ~ AWHC, slab.structure = c(0,100), slab.fun = mean, na.rm=TRUE)
d150 <- slab(data, id ~ AWHC, slab.structure = c(0,150), slab.fun = mean, na.rm=TRUE)
d200 <- slab(data, id ~ AWHC, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
s50 <- slab(data, id ~ AWHC, slab.structure = c(25,50), slab.fun = mean, na.rm=TRUE)
s100 <- slab(data, id ~ AWHC, slab.structure = c(50,100), slab.fun = mean, na.rm=TRUE)
s150 <- slab(data, id ~ AWHC, slab.structure = c(100,150), slab.fun = mean, na.rm=TRUE)
s200 <- slab(data, id ~ AWHC, slab.structure = c(150,200), slab.fun = mean, na.rm=TRUE)
# reshape to wide format, remove unneeded variables and rename.
AWC.0.25 <- dcast(d25, id + top + bottom ~ variable, value.var = 'value')
AWC.0.25 <- AWC.0.25[,-c(2,3)]
names(AWC.0.25)[2] <- 'AWC.0.25'
AWC.0.50 <- dcast(d50, id + top + bottom ~ variable, value.var = 'value')
AWC.0.50 <- AWC.0.50[,-c(2,3)]
names(AWC.0.50)[2] <- 'AWC.0.50'
AWC.0.100 <- dcast(d100, id + top + bottom ~ variable, value.var = 'value')
AWC.0.100 <- AWC.0.100[,-c(2,3)]
names(AWC.0.100)[2] <- 'AWC.0.100'
AWC.0.150 <- dcast(d150, id + top + bottom ~ variable, value.var = 'value')
AWC.0.150 <- AWC.0.150[,-c(2,3)]
names(AWC.0.150)[2] <- 'AWC.0.150'
AWC.0.200 <- dcast(d200, id + top + bottom ~ variable, value.var = 'value')
AWC.0.200 <- AWC.0.200[,-c(2,3)]
names(AWC.0.200)[2] <- 'AWC.0.200'
AWC.25.50 <- dcast(s50, id + top + bottom ~ variable, value.var = 'value')
AWC.25.50 <- AWC.25.50[,-c(2,3)]
names(AWC.25.50)[2] <- 'AWC.25.50'
AWC.50.100 <- dcast(s100, id + top + bottom ~ variable, value.var = 'value')
AWC.50.100 <- AWC.50.100[,-c(2,3)]
names(AWC.50.100)[2] <- 'AWC.50.100'
AWC.100.150 <- dcast(s150, id + top + bottom ~ variable, value.var = 'value')
AWC.100.150 <- AWC.100.150[,-c(2,3)]
names(AWC.100.150)[2] <- 'AWC.100.150'
AWC.150.200 <- dcast(s200, id + top + bottom ~ variable, value.var = 'value')
AWC.150.200 <- AWC.150.200[,-c(2,3)]
names(AWC.150.200)[2] <- 'AWC.150.200'
# within each profile, compute weighted means, removing NA if present
dwaclay <- slab(data, id ~ ClayPercent, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
dwasand <- slab(data, id ~ SandPercent, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
dwapH <- slab(data, id ~ pH, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
# reshape to wide format, remove unneeded variables and rename.
DWAClay <- dcast(dwaclay, id + top + bottom ~ variable, value.var = 'value')
DWAClay <- DWAClay[,-c(2,3)]
names(DWAClay)[2] <- 'DWAClay'
DWASand <- dcast(dwasand, id + top + bottom ~ variable, value.var = 'value')
DWASand <- DWASand[,-c(2,3)]
names(DWASand)[2] <- 'DWASand'
DWApH <- dcast(dwapH, id + top + bottom ~ variable, value.var = 'value')
DWApH <- DWApH[,-c(2,3)]
names(DWApH)[2] <- 'DWApH'
#Now calculate depth weighted averages of H2
#Convert to SoilProfileCollection
Sub <- H2
Sub$DryRed <- as.numeric(Sub$DryRed)
Sub$MoistRed <- as.numeric(Sub$MoistRed)
Sub$EfferScale <- as.numeric(Sub$EfferScale)
depths(Sub) <- id ~ top + bottom
# within each profile, compute weighted means, removing NA if present
subdwaclay <- slab(Sub, id ~ ClayPercent, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
subdwasand <- slab(Sub, id ~ SandPercent, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
subdwapH <- slab(Sub, id ~ pH, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
subawhc <- slab(Sub, id ~ AWHC, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
subdryred <- slab(Sub, id ~ DryRed, slab.structure = c(0,200), slab.fun = mean, na.rm=TRUE)
c <- slab(Sub, fm= ~ DryHue, cpm=1, slab.structure=0:200)
e <- slab(Sub, fm= ~ DryHue, cpm=2, slab.structure=0:200)
View(e)
View(c)
tail(e)
d <- slab(Sub, id ~ DryHue, cpm=1, slab.structure=0:200)
View(d)
tail(d)
View(e)
f <- slab(Sub, fm= id ~ DryHue, cpm=1, slab.structure=0:200)
View(f)
tail(f)
View(d)
View(e)
View(e)
View(e)
View(c)
c.long <- melt(c, id.vars=c('top','bottom'), measure.vars=c('X10YR','X2.5YR','X5YR','X7.5YR'))
View(c.long)
# plot horizon type proportions using panels
xyplot(top ~ value | variable, data=c.long, subset=value > 0,
ylim=c(200, -5), type=c('S','g'), horizontal=TRUE, layout=c(4,1), col=1 )
# again, this time using groups
xyplot(top ~ value, data=c.long, groups=variable, subset=value > 0,
ylim=c(150, -5), type=c('S','g'), horizontal=TRUE, asp=2)
g <- slab(Sub, id ~ DryHue, slab.structure = c(0,200), na.rm=TRUE)
View(g)
View(`H2`)
View(g)
a.long <- melt(a, id.vars=c('top','bottom'), measure.vars=c('X10YR','2.5YR','5YR','7.5YR'))
g.long <- melt(g, id.vars=c('id'), measure.vars=c('X10YR','2.5YR','5YR','7.5YR'))
g.long <- melt(g, id.vars=c('id'), measure.vars=c('X10YR','X2.5YR','X5YR','X7.5YR'))
View(g.long)
gg.long <- dcast(g.long, id + top + bottom ~ variable, value.var = 'value')
gg.long <- dcast(g.long, id ~ variable, value.var = 'value')
View(g.long)
